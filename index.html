<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Yana QR - Rider Register</title>

  <!-- ========== STYLES ========== -->
  <style>
    /* ---------- Theme & layout ---------- */
    :root{
      --bg:#000;
      --action:#00eaff;
      --muted: #9aa6ac;
      --card:#0b0b0b;
      --glass: rgba(255,255,255,0.03);
      --accent-text: #001f23;
      --radius:14px;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:#fff;}
    *{box-sizing:border-box}
    .container{
      max-width:1100px;margin:28px auto;padding:24px;
    }

    header{
      display:flex;align-items:center;gap:18px;margin-bottom:22px;
    }
    .logo{
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
    }
    .brand{font-size:18px;font-weight:600}
    .sub{font-size:12px;color:var(--muted)}
    .top-actions{margin-left:auto;display:flex;gap:10px;align-items:center}

    /* card */
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding:18px;border-radius:var(--radius);box-shadow:0 6px 24px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.03);
    }

    /* sign in/out */
    .btn{
      background:var(--action);border:none;color:#001; padding:10px 16px;border-radius:12px;font-weight:700;cursor:pointer;
      box-shadow:0 6px 18px rgba(0,234,255,0.12);
    }
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:600}
    .small{font-size:13px;padding:8px 10px;border-radius:10px;}

    /* two-column layout */
    .grid{display:grid;grid-template-columns:1fr 420px;gap:18px}
    @media(max-width:960px){ .grid{grid-template-columns:1fr} .logo{margin-right:auto}}

    /* scanner area */
    .scanner{
      display:flex;flex-direction:column;gap:12px;
    }
    #video{width:100%;border-radius:12px; background:#000; height:360px;object-fit:cover;border:1px solid rgba(255,255,255,0.03)}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    .status{padding:8px;border-radius:10px;background:var(--glass);color:var(--muted);font-size:13px}
    

     <video id="video" playsinline style="width:100%; max-width:400px; border:2px solid #00eaff; border-radius:12px;"></video>
     <p id="permissionStatus" style="color:white; text-align:center; margin-top:8px;">Camera idle</p>
     <p id="lastDecoded" style="color:#00eaff; text-align:center;"></p>
     <p id="lastDeviceInfo" style="color:#fff; text-align:center;"></p>
     <button id="startCamBtn" class="action-btn">Start Scanner</button>
     <button id="stopCamBtn" class="action-btn" style="display:none;">Stop Scanner</button>
     <button id="submitScanBtn" class="action-btn" disabled>Submit Scan</button>



    /* device info & logs */
    .info-row{display:flex;gap:10px;align-items:center;justify-content:space-between;margin-top:8px}
    .log-list{max-height:380px;overflow:auto;margin-top:8px;padding-right:8px}
    .log-item{padding:10px;border-radius:10px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.03);margin-bottom:8px;font-size:13px}
    .muted{color:var(--muted);font-size:13px}

    /* input & file */
    .file-input{display:flex;gap:8px;align-items:center}
    .logo-preview{width:56px;height:56px;border-radius:8px;background:transparent;display:flex;align-items:center;justify-content:center;overflow:hidden}
    input[type=file]{display:none}
    label.file-btn{padding:8px 10px;border-radius:10px;border:1px dashed rgba(255,255,255,0.06);cursor:pointer;font-size:13px;color:var(--muted)}

    footer{margin-top:18px;color:var(--muted);font-size:13px;text-align:center}
  </style>
</head>

<body>
  <div class="container">
    <!-- HEADER: logo, brand, signin, svg upload -->
    <header>
    <img src="logo.svg" alt="App Logo" class="app-logo">

      <div class="logo card" id="logo-container" title="Click to upload new SVG logo (below)">
          <rect x="2" y="2" width="20" height="20" rx="4" fill="#00eaff" />
          <path d="M7 12h10M12 7v10" stroke="#001f23" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </div>

      <div>
        <div class="brand">Yana — Rider QR</div>
        <div class="sub">Scan · Register · Log</div>
      </div>

      <div class="top-actions">
        <div id="user-email" class="muted">Not signed in</div>
        <button id="signinBtn" class="btn small">Sign in with Google</button>
        <button id="signoutBtn" class="btn small ghost" style="display:none">Sign out</button>
      </div>
    </header>

    <div class="grid">
      <!-- LEFT: Scanner + controls -->
      <div class="card scanner">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">Start Scanning</div>
        </div>

        <!-- video preview -->
        <video id="video" playsinline></video>

        <!-- controls -->
        <div class="controls">
          <button id="startCam" class="btn small">Start Camera</button>
          <button id="stopCam" class="btn small ghost">Stop Camera</button>

          <select id="scanMode" class="small" style="background:transparent;border:1px solid rgba(255,255,255,0.06);color:#fff;padding:8px;border-radius:10px">
            <option value="auto">Auto-detect (scooter/battery)</option>
            <option value="scooter">Force: Scooter</option>
            <option value="battery">Force: Battery</option>
          </select>

          <div id="permissionStatus" class="status">Camera idle</div>
        </div>

        <!-- last scan + action -->
        <div class="info-row">
          <div>
            <div class="muted">Last decoded</div>
            <div id="lastDecoded" style="font-weight:700">—</div>
            <div class="muted" id="lastDeviceInfo">—</div>
          </div>
          <div style="text-align:right">
            <button id="submitScan" class="btn small" disabled>Submit</button>
            <div class="muted" style="margin-top:6px;font-size:12px">Scan → Submit</div>
          </div>
        </div>

        <div class="muted" style="margin-top:8px;font-size:13px">Tip: QR payloads like <code>scooter:SC001</code> or <code>battery:BAT100</code> work best. Plain IDs are auto-detected.</div>

      </div>

      <!-- RIGHT: summary, device status, logs, upload logo -->
      <aside class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">Rider & Devices</div>
        </div>

        <div style="margin-top:12px">
          <div class="muted">Signed-in rider</div>
          <div id="riderInfo" style="font-weight:700;margin-top:6px">—</div>

          <div style="margin-top:12px" class="muted">Linked scooter</div>
          <div id="linkedScooter" style="font-weight:700;margin-top:6px">—</div>

          <div style="margin-top:12px" class="muted">Linked battery</div>
          <div id="linkedBattery" style="font-weight:700;margin-top:6px">—</div>
        </div>

        <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03);margin:14px 0">

        <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
          <div style="font-weight:700">Recent logs</div>
          <button id="refreshLogs" class="btn small ghost">Refresh</button>
        </div>

        <div class="log-list" id="logList">
          <!-- dynamic logs -->
        </div>
      </aside>
    </div>

    <footer class="muted">Built for Yana — keep your riders & devices tracked. Logs saved to Firestore.</footer>
  </div>

  <!-- ========== SCRIPTS ========== -->
  <!-- Firebase JS SDKs (modular) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <!-- QR decoding library: jsQR (lightweight) -->
  <script src="https://unpkg.com/jsqr/dist/jsQR.js"></script>

  <script>
  /**************************************************************************
   * ========================= IMPORTANT CONFIG ============================
   * Replace the firebaseConfig below with what you provided (already done).
   * This page uses Firebase Authentication (Google popup) + Firestore.
   **************************************************************************/

  const firebaseConfig = {
    apiKey: "AIzaSyCP7KKqJhtauDVonZ-6ApHRitu7CCdV0Ns",
    authDomain: "yana-qr.firebaseapp.com",
    projectId: "yana-qr",
    storageBucket: "yana-qr.firebasestorage.app",
    messagingSenderId: "905613005387",
    appId: "1:905613005387:web:b0d8464d826972654b73ce",
    measurementId: "G-9P9DLJGQHQ"
  };

  // ========== Initialize Firebase ==========
  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.firestore();

  /**************************************************************************
   * ========================= UI ELEMENTS =================================
   **************************************************************************/
  const video = document.getElementById('video');
  const startCamBtn = document.getElementById('startCam');
  const stopCamBtn = document.getElementById('stopCam');
  const permissionStatus = document.getElementById('permissionStatus');
  const lastDecoded = document.getElementById('lastDecoded');
  const lastDeviceInfo = document.getElementById('lastDeviceInfo');
  const submitScanBtn = document.getElementById('submitScan');
  const scanMode = document.getElementById('scanMode');
  const signinBtn = document.getElementById('signinBtn');
  const signoutBtn = document.getElementById('signoutBtn');
  const userEmailEl = document.getElementById('user-email');
  const riderInfo = document.getElementById('riderInfo');
  const linkedScooter = document.getElementById('linkedScooter');
  const linkedBattery = document.getElementById('linkedBattery');
  const logList = document.getElementById('logList');
  const refreshLogs = document.getElementById('refreshLogs');

  /**************************************************************************
   * ========================= AUTHENTICATION ===============================
   * We use Firebase Google provider with a single-click popup sign-in.
   * If you want Google One-Tap later, you'll need an OAuth client ID
   * from Google Cloud and small integration changes.
   **************************************************************************/

  signinBtn.addEventListener('click', async () => {
    try{
      signinBtn.disabled = true;
      const provider = new firebase.auth.GoogleAuthProvider();
      await auth.signInWithPopup(provider);
      signinBtn.disabled = false;
    }catch(e){
      console.error('Sign-in failed', e);
      alert('Sign-in failed: '+e.message);
      signinBtn.disabled = false;
    }
  });

  signoutBtn.addEventListener('click', async ()=>{
    await auth.signOut();
  });

  // Auth state change listener (updates UI & loads user doc)
  auth.onAuthStateChanged(async (user)=>{
    if(user){
      userEmailEl.textContent = user.email;
      riderInfo.textContent = `${user.displayName || 'Rider'} (${user.email})`;
      signinBtn.style.display = 'none';
      signoutBtn.style.display = 'inline-block';

      // ensure user doc exists
      const uDocRef = db.collection('users').doc(user.email);
      const uDoc = await uDocRef.get();
      if(!uDoc.exists){
        await uDocRef.set({
          email: user.email,
          name: user.displayName||null,
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          linkedScooter: null,
          linkedBattery: null
        });
      }
      // refresh user's linked devices
      loadUserDevices();
      // refresh some recent logs
      loadLogs();
    } else {
      userEmailEl.textContent = 'Not signed in';
      riderInfo.textContent = '—';
      linkedScooter.textContent = '—';
      linkedBattery.textContent = '—';
      signinBtn.style.display = 'inline-block';
      signoutBtn.style.display = 'none';
      logList.innerHTML = '';
    }
  });

  /**************************************************************************
   * ========================= CAMERA & QR SCANNER ===========================
   * We'll use getUserMedia, draw frames to a hidden canvas, run jsQR on them.
   **************************************************************************/
  let stream = null;
  let scanning = false;
  let scanInterval = null;
  let lastRawResult = null;
  let lastParsedResult = { type: 'unknown', id: '', raw: '' };

  // helper: start camera
  async function startCamera(){
    try{
      permissionStatus.textContent = 'Requesting camera...';
      stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
      video.srcObject = stream;
      await video.play();
      permissionStatus.textContent = 'Camera active';
      startCamBtn.style.display = 'none';
      stopCamBtn.style.display = 'inline-block';
      scanning = true;
      scanLoop();
    }catch(err){
      console.error('Camera error', err);
      permissionStatus.textContent = 'Camera permission denied or not available';
      alert('Camera access is required for scanning. Please allow camera permissions and try again.');
    }
  }

  // helper: stop camera
  function stopCamera(){
    scanning = false;
    permissionStatus.textContent = 'Camera stopped';
    startCamBtn.style.display = 'inline-block';
    stopCamBtn.style.display = 'none';
    if(stream){
      stream.getTracks().forEach(t=>t.stop());
      stream = null;
    }
    if(scanInterval){ clearInterval(scanInterval); scanInterval = null; }
  }

  startCamBtn.addEventListener('click', startCamera);
  stopCamBtn.addEventListener('click', stopCamera);

  // main scan loop: create a canvas and run jsQR on image data every 300ms
  function scanLoop(){
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    scanInterval = setInterval(async ()=>{
      try{
        if(!scanning || video.readyState !== video.HAVE_ENOUGH_DATA) return;
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.drawImage(video,0,0,canvas.width,canvas.height);
        const imageData = ctx.getImageData(0,0,canvas.width,canvas.height);
        const code = jsQR(imageData.data, imageData.width, imageData.height, {inversionAttempts: "attemptBoth"});
        if(code){
          // got a QR result
          lastRawResult = code.data.trim();
          lastDecoded.textContent = lastRawResult;

          // YANA_RULE: Use async Firestore-backed / heuristic detection instead of devices.txt.
          // Determine device type (async) and update UI accordingly.
          try {
            const parsed = await determineDeviceType(lastRawResult);
            lastParsedResult = parsed;
            lastDeviceInfo.textContent = parsed.type === 'unknown' ? `UNKNOWN: ${parsed.id}` : `${parsed.type.toUpperCase()}: ${parsed.id}`;
            submitScanBtn.disabled = parsed.type === 'unknown';
            permissionStatus.textContent = parsed.type === 'unknown' ? `Unknown device` : `Detected ${parsed.type} ${parsed.id}`;
            console.log('Parsed QR', parsed);
          } catch (err) {
            console.error('Error determining device type', err);
            permissionStatus.textContent = 'Parse error';
            submitScanBtn.disabled = true;
          }
        }
      }catch(err){
        console.error('Scan loop error', err);
      }
    }, 300);
  }

  /**************************************************************************
   * ========================= PARSING LOGIC =================================
   * YANA_RULE: Remove dependency on devices.txt; use heuristics + Firestore to
   * determine whether a scanned ID is a scooter or a battery.
   **************************************************************************/

  // YANA_RULE: determineDeviceType attempts the following (in order):
  // 1) Respect scanMode dropdown if forced
  // 2) Heuristics: YEV* -> scooter, YBT* -> battery, payload prefixes 'scooter:'/'battery:' or 'SC','BAT' variants
  // 3) Firestore lookup: check devices collection for scooter_<ID> or battery_<ID>
  // Returns {type: 'scooter'|'battery'|'unknown', id: '...', raw: '...'}
  async function determineDeviceType(raw) {
    if(!raw) return { type: 'unknown', id: '', raw };

    const rawTrim = raw.trim();
    let id = rawTrim;
    // if payloads like scooter:SC001 or battery:BAT001, extract after colon
    if(rawTrim.includes(':')) {
      const parts = rawTrim.split(':');
      id = parts.slice(1).join(':').trim();
    }
    id = id.toUpperCase();

    // YANA_RULE: honor scanMode override
    const mode = (scanMode && scanMode.value) ? scanMode.value : 'auto';
    if(mode === 'scooter') return { type: 'scooter', id, raw: rawTrim };
    if(mode === 'battery') return { type: 'battery', id, raw: rawTrim };

    // YANA_RULE: heuristics for common prefixes
    try {
      if(/^YEV\d+/i.test(id) || /^SCOT|^SC\d+|^SC[0-9]/i.test(id) || /^SCOOTER/i.test(id) ) {
        return { type: 'scooter', id, raw: rawTrim };
      }
      if(/^YBT\d+/i.test(id) || /^BAT\d+|^BATTERY/i.test(id)) {
        return { type: 'battery', id, raw: rawTrim };
      }
    } catch (e) {
      console.warn('Heuristic check failed', e);
    }

    // YANA_RULE: fallback to Firestore devices lookup:
    // Check scooter_<ID> and battery_<ID> docs to see if either exists
    try {
      const scooterRef = db.collection('devices').doc(`scooter_${id}`);
      const batteryRef = db.collection('devices').doc(`battery_${id}`);
      const [sSnap, bSnap] = await Promise.all([scooterRef.get(), batteryRef.get()]);

      if(sSnap.exists){
        const d = sSnap.data() || {};
        return { type: 'scooter', id, raw: rawTrim, source: 'devices_collection', deviceDoc: d };
      }
      if(bSnap.exists){
        const d = bSnap.data() || {};
        return { type: 'battery', id, raw: rawTrim, source: 'devices_collection', deviceDoc: d };
      }

      // still unknown
      console.warn('Unknown device id scanned:', id);
      return { type: 'unknown', id, raw: rawTrim };
    } catch (err) {
      console.error('Firestore lookup failed when determining device type', err);
      return { type: 'unknown', id, raw: rawTrim };
    }
  }

  /**************************************************************************
   * ========================= SUBMIT / REGISTER LOGIC =======================
   * - ensures a user must sign in
   * - ensures user can have only one scooter and one battery
   * - toggles registration/deregistration when same device is scanned
   * - logs every action in `logs` collection
   *
   * Firestore collections used:
   *  - users (doc id = user.email) : { linkedScooter, linkedBattery, ... }
   *  - devices (doc id = <type>_<ID>) :
   *      scooter doc: { type:'scooter', linkedTo: email|null, currentBatteryId: null|batteryId, currentRiderEmail: email|null }
   *      battery doc: { type:'battery', linkedTo: email|null, assignedScootyId: null|scooterId, assignedRiderEmail: email|null }
   *  - logs (auto id) : {ts, email, action, deviceType, deviceId, rawPayload}
   *
   * YANA_RULE: All reads/writes are inside transactions with null checks.
   **************************************************************************/
  submitScanBtn.addEventListener('click', async ()=>{
    const user = auth.currentUser;
    if(!user){
      alert('Please sign in with Google first.');
      return;
    }
    if(!lastRawResult){
      alert('No QR code scanned yet. Please scan and then submit.');
      return;
    }

    // If determineDeviceType wasn't yet executed (rare) run it now
    let parsed = lastParsedResult && lastParsedResult.raw === lastRawResult ? lastParsedResult : await determineDeviceType(lastRawResult);

    if(parsed.type === 'unknown'){
      if(!confirm('Unable to detect device type (scooter/battery). Submit as plain device id?')) {
        return;
      }
      alert('Unknown device type cannot be processed automatically. Use the scan-mode dropdown to force scooter or battery.');
      return;
    }

    // perform transactional checks & updates
    try{
      submitScanBtn.disabled = true;
      permissionStatus.textContent = 'Processing...';
      await processScan(user.email, parsed.type, parsed.id, parsed.raw);
      permissionStatus.textContent = 'Done';
      // update UI
      loadUserDevices();
      loadLogs();
      submitScanBtn.disabled = false;
    }catch(e){
      submitScanBtn.disabled = false;
      permissionStatus.textContent = 'Error';
      alert('Operation failed: ' + (e && e.message ? e.message : e));
      console.error(e);
    }
  });

  /**
   * processScan: core logic for register/deregister
   * - Ensures atomicity using Firestore transactions
   *
   * YANA_RULE: This function enforces:
   *  - scooter assignment, battery assignment preconditions
   *  - scooter return with battery (clears rider+device+battery links together)
   *  - battery return only (clears only battery links)
   *  - auto-heal orphaned scooter->battery links
   */
  async function processScan(email, deviceType, deviceId, rawPayload){
    if(!email) throw new Error('Missing user email');
    if(!deviceType || !deviceId) throw new Error('Invalid device info');

    // canonicalize device doc id (prefix with type to avoid conflicts)
    const devDocId = `${deviceType}_${deviceId}`;
    const userRef = db.collection('users').doc(email);
    const devRef = db.collection('devices').doc(devDocId);
    const logsRef = db.collection('logs');

    await db.runTransaction(async (tx)=>{
      const userSnap = await tx.get(userRef);
      if(!userSnap.exists){
        throw new Error('User document missing. Sign-in again.');
      }
      const userData = userSnap.data() || {};
      const userLinkedScooter = userData.linkedScooter || null;
      const userLinkedBattery = userData.linkedBattery || null;

      // get device doc (if exists)
      let devSnap = await tx.get(devRef);
      let devData = devSnap.exists ? (devSnap.data() || {}) : null;

      // if device doc missing, create with canonical fields (YANA_RULE)
      if(!devData){
        if(deviceType === 'scooter') {
          devData = { type: 'scooter', linkedTo: null, currentBatteryId: null, currentRiderEmail: null, createdAt: firebase.firestore.FieldValue.serverTimestamp(), lastSeen: firebase.firestore.FieldValue.serverTimestamp() };
        } else {
          devData = { type: 'battery', linkedTo: null, assignedScootyId: null, assignedRiderEmail: null, createdAt: firebase.firestore.FieldValue.serverTimestamp(), lastSeen: firebase.firestore.FieldValue.serverTimestamp() };
        }
        tx.set(devRef, devData);
      } else {
        // ensure device doc has minimal fields (backfill absent fields)
        if(deviceType === 'scooter') {
          const patch = {};
          if(typeof devData.currentBatteryId === 'undefined') patch.currentBatteryId = null;
          if(typeof devData.currentRiderEmail === 'undefined') patch.currentRiderEmail = devData.linkedTo || null;
          if(Object.keys(patch).length) tx.update(devRef, patch);
        } else {
          const patch = {};
          if(typeof devData.assignedScootyId === 'undefined') patch.assignedScootyId = null;
          if(typeof devData.assignedRiderEmail === 'undefined') patch.assignedRiderEmail = devData.linkedTo || null;
          if(Object.keys(patch).length) tx.update(devRef, patch);
        }
      }

      // YANA_RULE: Auto-heal invalid states for scooters that have a battery but no rider.
      // If scooter doc has currentBatteryId but linkedTo (or currentRiderEmail) is null, we clear both sides.
      if(deviceType === 'scooter') {
        // if there's an orphaned battery on this scooter
        if(devData && devData.currentBatteryId && !devData.linkedTo){
          const orphanBatteryId = devData.currentBatteryId;
          const batteryRef = db.collection('devices').doc(`battery_${orphanBatteryId}`);
          const bSnap = await tx.get(batteryRef);
          if(bSnap.exists){
            const bData = bSnap.data() || {};
            // clear battery assignment if it points to this scooter
            if(bData.assignedScootyId === deviceId || bData.assignedScootyId === null) {
              tx.update(batteryRef, { assignedScootyId: null, assignedRiderEmail: null, lastSeen: firebase.firestore.FieldValue.serverTimestamp() });
            }
          }
          // clear scooter's battery link
          tx.update(devRef, { currentBatteryId: null, lastSeen: firebase.firestore.FieldValue.serverTimestamp() });
          // log auto_heal
          tx.set(logsRef.doc(), {
            ts: firebase.firestore.FieldValue.serverTimestamp(),
            email: 'system',
            action: 'auto_heal',
            details: `Cleared orphan battery ${orphanBatteryId} from scooter ${deviceId} (no rider present)`,
            deviceType: 'scooter',
            deviceId,
            rawPayload: rawPayload
          });
          // refresh local devData reflector
          devData.currentBatteryId = null;
        }
      }

      // Re-get updated devData snapshot if needed (optional)
      // Now apply main logic depending on deviceType

      if(deviceType === 'scooter'){
        // CASE A: user has no linked scooter -> attempt to link scooter
        if(!userLinkedScooter){
          // scooter must be unlinked
          if(devData.linkedTo && devData.linkedTo !== email){
            throw new Error(`Scooter ${deviceId} is already linked to another rider (${devData.linkedTo}).`);
          }
          // link scooter to user
          tx.update(userRef, { linkedScooter: deviceId, updatedAt: firebase.firestore.FieldValue.serverTimestamp() });
          tx.update(devRef, { linkedTo: email, currentRiderEmail: email, lastSeen: firebase.firestore.FieldValue.serverTimestamp() });
          tx.set(logsRef.doc(), {
            ts: firebase.firestore.FieldValue.serverTimestamp(),
            email, action: 'register', deviceType: 'scooter', deviceId, rawPayload
          });
          return;
        }

        // CASE B: user already linked to a scooter
        if(userLinkedScooter === deviceId){
          // deregister scooter -> check if scooter has a battery -> if so, clear scooter+rider+battery together (Scooter Return with battery)
          if(devData.currentBatteryId){
            const batteryId = devData.currentBatteryId;
            const batteryRef = db.collection('devices').doc(`battery_${batteryId}`);
            const bSnap = await tx.get(batteryRef);
            const bData = bSnap.exists ? bSnap.data() : null;

            // Clear user linked fields
            tx.update(userRef, { linkedScooter: null, linkedBattery: null, updatedAt: firebase.firestore.FieldValue.serverTimestamp() });

            // Clear scooter fields
            tx.update(devRef, { linkedTo: null, currentBatteryId: null, currentRiderEmail: null, lastSeen: firebase.firestore.FieldValue.serverTimestamp() });

            // Clear battery fields — only if battery is indeed assigned to this scooter / rider
            if(bData){
              if(bData.assignedScootyId === deviceId || bData.assignedRiderEmail === email || bData.linkedTo === email){
                tx.update(batteryRef, { assignedScootyId: null, assignedRiderEmail: null, linkedTo: null, lastSeen: firebase.firestore.FieldValue.serverTimestamp() });
              } else {
                // as a safety, still clear assigned fields referencing this scooter
                const patch = {};
                if(bData.assignedScootyId === deviceId) patch.assignedScootyId = null;
                if(bData.assignedRiderEmail === email) patch.assignedRiderEmail = null;
                if(Object.keys(patch).length) tx.update(batteryRef, { ...patch, lastSeen: firebase.firestore.FieldValue.serverTimestamp() });
              }
            }

            tx.set(logsRef.doc(), {
              ts: firebase.firestore.FieldValue.serverTimestamp(),
              email, action: 'return_scooter_with_battery', deviceType: 'scooter', deviceId, batteryId, rawPayload
            });
            return;
          }

          // if scooter has no battery, simple deregister
          tx.update(userRef, { linkedScooter: null, updatedAt: firebase.firestore.FieldValue.serverTimestamp() });
          tx.update(devRef, { linkedTo: null, currentRiderEmail: null, lastSeen: firebase.firestore.FieldValue.serverTimestamp() });
          tx.set(logsRef.doc(), {
            ts: firebase.firestore.FieldValue.serverTimestamp(),
            email, action: 'deregister', deviceType: 'scooter', deviceId, rawPayload
          });
          return;
        }

        // CASE C: user linked to a DIFFERENT scooter: reject and ask to deregister first
        throw new Error(`You already have a linked scooter (${userLinkedScooter}). Please deregister it first by scanning that scooter's QR and submitting.`);

      } else if(deviceType === 'battery'){
        // Battery handling rules

        // Precondition: Rider must have a scooter
        if(!userLinkedScooter){
          throw new Error('You must have a scooter linked before assigning a battery. Scan and register a scooter first.');
        }

        // CASE A: user has no linked battery -> attempt to link battery
        if(!userLinkedBattery){
          // battery must be free OR already linked to rider's scooter
          // check devData.assignedScootyId or devData.linkedTo
          if(devData.linkedTo && devData.linkedTo !== email){
            // if assigned to someone else, reject
            throw new Error(`Battery ${deviceId} is already linked to another rider (${devData.linkedTo}).`);
          }
          // allow assignment if battery is free OR assigned to this scooter
          if(devData.assignedScootyId && devData.assignedScootyId !== userLinkedScooter){
            throw new Error(`Battery ${deviceId} is assigned to scooter ${devData.assignedScootyId}. Cannot assign to your scooter ${userLinkedScooter}.`);
          }

          // All good: update battery, scooter, and user atomically
          const batteryRef = devRef; // battery doc
          const scooterRef = db.collection('devices').doc(`scooter_${userLinkedScooter}`);

          // Update battery doc
          tx.update(batteryRef, {
            assignedScootyId: userLinkedScooter,
            assignedRiderEmail: email,
            linkedTo: email,
            lastSeen: firebase.firestore.FieldValue.serverTimestamp()
          });

          // Update scooter doc: set currentBatteryId if not already set or it's the same battery
          const sSnap = await tx.get(scooterRef);
          if(!sSnap.exists){
            // create minimal scooter doc if missing (shouldn't usually happen)
            tx.set(scooterRef, { type: 'scooter', linkedTo: email, currentBatteryId: deviceId, currentRiderEmail: email, createdAt: firebase.firestore.FieldValue.serverTimestamp(), lastSeen: firebase.firestore.FieldValue.serverTimestamp() });
          } else {
            const sData = sSnap.data() || {};
            if(sData.currentBatteryId && sData.currentBatteryId !== deviceId){
              throw new Error(`Your scooter already has battery ${sData.currentBatteryId}. Remove that battery first.`);
            }
            tx.update(scooterRef, { currentBatteryId: deviceId, lastSeen: firebase.firestore.FieldValue.serverTimestamp() });
          }

          // Update user doc
          tx.update(userRef, { linkedBattery: deviceId, updatedAt: firebase.firestore.FieldValue.serverTimestamp() });

          // Log
          tx.set(logsRef.doc(), {
            ts: firebase.firestore.FieldValue.serverTimestamp(),
            email, action: 'register', deviceType: 'battery', deviceId, scooterId: userLinkedScooter, rawPayload
          });
          return;
        }

        // CASE B: user already linked to a battery
        if(userLinkedBattery === deviceId){
          // Deregister battery only (Battery Return)
          const batteryRef = devRef;
          const scooterRef = db.collection('devices').doc(`scooter_${userLinkedScooter}`);

          // Clear user -> battery link
          tx.update(userRef, { linkedBattery: null, updatedAt: firebase.firestore.FieldValue.serverTimestamp() });

          // Clear scooter's currentBatteryId only if it references this battery
          const sSnap = await tx.get(scooterRef);
          if(sSnap.exists){
            const sData = sSnap.data() || {};
            if(sData.currentBatteryId === deviceId){
              tx.update(scooterRef, { currentBatteryId: null, lastSeen: firebase.firestore.FieldValue.serverTimestamp() });
            }
          }

          // Clear battery fields if linked to this user
          if(devData.linkedTo === email || devData.assignedRiderEmail === email || devData.assignedScootyId === userLinkedScooter){
            tx.update(batteryRef, { assignedScootyId: null, assignedRiderEmail: null, linkedTo: null, lastSeen: firebase.firestore.FieldValue.serverTimestamp() });
          }

          tx.set(logsRef.doc(), {
            ts: firebase.firestore.FieldValue.serverTimestamp(),
            email, action: 'return_battery', deviceType: 'battery', deviceId, scooterId: userLinkedScooter, rawPayload
          });
          return;
        }

        // CASE C: user already linked to a DIFFERENT battery
        throw new Error(`You already have a linked battery (${userLinkedBattery}). Please return it first by scanning that battery's QR and submitting.`);
      }

      // default safe fallback
      throw new Error('Unhandled device type.');
    });
  }

  /**************************************************************************
   * ========================= UI: load user & logs ==========================
   **************************************************************************/
  async function loadUserDevices(){
    const user = auth.currentUser;
    if(!user) return;
    const uDoc = await db.collection('users').doc(user.email).get();
    const data = uDoc.exists ? uDoc.data() : null;
    linkedScooter.textContent = data && data.linkedScooter ? data.linkedScooter : '—';
    linkedBattery.textContent = data && data.linkedBattery ? data.linkedBattery : '—';
  }

  // load recent logs (last 50)
  async function loadLogs(){
    logList.innerHTML = `<div class="muted">Loading logs...</div>`;
    const q = db.collection('logs').orderBy('ts','desc').limit(50);
    const snap = await q.get();
    logList.innerHTML = '';
    if(snap.empty){
      logList.innerHTML = '<div class="muted">No logs yet</div>';
      return;
    }
    snap.forEach(doc=>{
      const d = doc.data();
      const when = d.ts ? new Date(d.ts.toDate()).toLocaleString() : '—';
      const el = document.createElement('div');
      el.className = 'log-item';
      el.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center">
        <div><strong>${d.action ? d.action.toUpperCase() : 'LOG'}</strong> &nbsp; ${d.deviceType || ''} <span style="opacity:.9">(${d.deviceId || ''})</span></div>
        <div class="muted" style="font-size:12px">${when}</div>
      </div>
      <div class="muted" style="margin-top:6px">user: ${d.email || '—'} • payload: <code>${escapeHtml(d.rawPayload || '')}</code></div>`;
      logList.appendChild(el);
    });
  }
  refreshLogs.addEventListener('click', loadLogs);

  // helper to escape HTML
  function escapeHtml(s){ return (s+'').replace(/[&<>"]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

  /**************************************************************************
   * ========================= SVG UPLOAD (logo change) =====================
   * Allows upload of an SVG file and replaces inline logo preview and main SVG.
   **************************************************************************/
  /*svgUpload.addEventListener('change', (ev)=>{
    const f = ev.target.files[0];
    if(!f) return;
    if(!f.name.toLowerCase().endsWith('.svg')) return alert('Please upload an SVG file only.');
    const reader = new FileReader();
    reader.onload = (e)=>{
      const contents = e.target.result;
      // simple safety: replace the innerHTML of the preview and main logo
      try{
        svgPreview.innerHTML = contents;
        // update main header logo too (if safe)
        document.getElementById('logo-container').innerHTML = contents;
      }catch(err){
        alert('SVG parse error');
        console.error(err);
      }
    };
    reader.readAsText(f);
  });

  // Clicking the logo also opens file upload (UX)
  document.getElementById('logo-container').addEventListener('click', ()=> svgUpload.click());*/

  /**************************************************************************
   * ========================= UTIL: Page unload cleanup ====================
   **************************************************************************/
  window.addEventListener('beforeunload', ()=>{
    if(stream) stream.getTracks().forEach(t=>t.stop());
  });

  /**************************************************************************
   * ========================= INITIAL SIMPLE SETUP =========================
   * Try to load logs once if the user is already signed in
   **************************************************************************/
  (async ()=>{
    // nothing to do here beyond what onAuthStateChanged handles.
  })();

  </script>
</body>
</html>
