<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Yana QR - Rider Register</title>

  <!-- ========== STYLES ========== -->
  <style>
    /* ---------- Theme & layout ---------- */
    :root{
      --bg:#000;
      --action:#00eaff;
      --muted: #9aa6ac;
      --card:#0b0b0b;
      --glass: rgba(255,255,255,0.03);
      --accent-text: #001f23;
      --radius:14px;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:#fff;}
    *{box-sizing:border-box}
    .container{
      max-width:1100px;margin:28px auto;padding:24px;
    }

    header{
      display:flex;align-items:center;gap:18px;margin-bottom:22px;
    }
    .logo{
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
    }
    .brand{font-size:18px;font-weight:600}
    .sub{font-size:12px;color:var(--muted)}
    .top-actions{margin-left:auto;display:flex;gap:10px;align-items:center}

    /* card */
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding:18px;border-radius:var(--radius);box-shadow:0 6px 24px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.03);
    }

    /* sign in/out */
    .btn{
      background:var(--action);border:none;color:#001; padding:10px 16px;border-radius:12px;font-weight:700;cursor:pointer;
      box-shadow:0 6px 18px rgba(0,234,255,0.12);
    }
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:600}
    .small{font-size:13px;padding:8px 10px;border-radius:10px;}

    /* two-column layout */
    .grid{display:grid;grid-template-columns:1fr 420px;gap:18px}
    @media(max-width:960px){ .grid{grid-template-columns:1fr} .logo{margin-right:auto}}

    /* scanner area */
    .scanner{
      display:flex;flex-direction:column;gap:12px;
    }
    #video{width:100%;border-radius:12px; background:#000; height:360px;object-fit:cover;border:1px solid rgba(255,255,255,0.03)}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    .status{padding:8px;border-radius:10px;background:var(--glass);color:var(--muted);font-size:13px}

    /* YANA_RULE: Removed accidental HTML tags that were inside <style>.
       Those tags broke CSS parsing and could impact layout/rendering. */
    /* (No other changes in CSS) */

    /* device info & logs */
    .info-row{display:flex;gap:10px;align-items:center;justify-content:space-between;margin-top:8px}
    .log-list{max-height:380px;overflow:auto;margin-top:8px;padding-right:8px}
    .log-item{padding:10px;border-radius:10px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.03);margin-bottom:8px;font-size:13px}
    .muted{color:var(--muted);font-size:13px}

    /* input & file */
    .file-input{display:flex;gap:8px;align-items:center}
    .logo-preview{width:56px;height:56px;border-radius:8px;background:transparent;display:flex;align-items:center;justify-content:center;overflow:hidden}
    input[type=file]{display:none}
    label.file-btn{padding:8px 10px;border-radius:10px;border:1px dashed rgba(255,255,255,0.06);cursor:pointer;font-size:13px;color:var(--muted)}

    footer{margin-top:18px;color:var(--muted);font-size:13px;text-align:center}
  </style>
</head>

<body>
  <div class="container">
    <!-- HEADER: logo, brand, signin, svg upload -->
    <header>
      <img src="logo.svg" alt="App Logo" class="app-logo">

      <div class="logo card" id="logo-container" title="Click to upload new SVG logo (below)">
        <!-- YANA_RULE: Wrap loose <rect>/<path> with a valid <svg> to fix broken markup -->
        <svg viewBox="0 0 24 24" width="28" height="28" aria-hidden="true">
          <rect x="2" y="2" width="20" height="20" rx="4" fill="#00eaff" />
          <path d="M7 12h10M12 7v10" stroke="#001f23" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </div>

      <div>
        <div class="brand">Yana — Rider QR</div>
        <div class="sub">Scan · Register · Log</div>
      </div>

      <div class="top-actions">
        <div id="user-email" class="muted">Not signed in</div>
        <button id="signinBtn" class="btn small">Sign in with Google</button>
        <button id="signoutBtn" class="btn small ghost" style="display:none">Sign out</button>
      </div>
    </header>

    <div class="grid">
      <!-- LEFT: Scanner + controls -->
      <div class="card scanner">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">Start Scanning</div>
        </div>

        <!-- video preview -->
        <video id="video" playsinline></video>

        <!-- controls -->
        <div class="controls">
          <button id="startCam" class="btn small">Start Camera</button>
          <button id="stopCam" class="btn small ghost">Stop Camera</button>

          <select id="scanMode" class="small" style="background:transparent;border:1px solid rgba(255,255,255,0.06);color:#fff;padding:8px;border-radius:10px">
            <option value="auto">Auto-detect (scooter/battery)</option>
            <option value="scooter">Force: Scooter</option>
            <option value="battery">Force: Battery</option>
          </select>

          <div id="permissionStatus" class="status">Camera idle</div>
        </div>

        <!-- last scan + action -->
        <div class="info-row">
          <div>
            <div class="muted">Last decoded</div>
            <div id="lastDecoded" style="font-weight:700">—</div>
            <div class="muted" id="lastDeviceInfo">—</div>
          </div>
          <div style="text-align:right">
            <button id="submitScan" class="btn small" disabled>Submit</button>
            <div class="muted" style="margin-top:6px;font-size:12px">Scan → Submit</div>
          </div>
        </div>

        <div class="muted" style="margin-top:8px;font-size:13px">Tip: QR payloads like <code>scooter:SC001</code> or <code>battery:BAT100</code> work best. Plain IDs are auto-detected.</div>

      </div>

      <!-- RIGHT: summary, device status, logs, upload logo -->
      <aside class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">Rider & Devices</div>
        </div>

        <div style="margin-top:12px">
          <div class="muted">Signed-in rider</div>
          <div id="riderInfo" style="font-weight:700;margin-top:6px">—</div>

          <div style="margin-top:12px" class="muted">Linked scooter</div>
          <div id="linkedScooter" style="font-weight:700;margin-top:6px">—</div>

          <div style="margin-top:12px" class="muted">Linked battery</div>
          <div id="linkedBattery" style="font-weight:700;margin-top:6px">—</div>
        </div>

        <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03);margin:14px 0">

        <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
          <div style="font-weight:700">Recent logs</div>
          <button id="refreshLogs" class="btn small ghost">Refresh</button>
        </div>

        <div class="log-list" id="logList">
          <!-- dynamic logs -->
        </div>
      </aside>
    </div>

    <footer class="muted">Built for Yana — keep your riders & devices tracked. Logs saved to Firestore.</footer>
  </div>

  <!-- ========== SCRIPTS ========== -->
  <!-- Firebase JS SDKs (modular compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <!-- QR decoding library: jsQR (lightweight) -->
  <script src="https://unpkg.com/jsqr/dist/jsQR.js"></script>

  <script>
  /**************************************************************************
   * ========================= IMPORTANT CONFIG ============================
   **************************************************************************/

  const firebaseConfig = {
    apiKey: "AIzaSyCP7KKqJhtauDVonZ-6ApHRitu7CCdV0Ns",
    authDomain: "yana-qr.firebaseapp.com",
    projectId: "yana-qr",
    storageBucket: "yana-qr.firebasestorage.app",
    messagingSenderId: "905613005387",
    appId: "1:905613005387:web:b0d8464d826972654b73ce",
    measurementId: "G-9P9DLJGQHQ"
  };

  // ========== Initialize Firebase ==========
  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.firestore();

  /**************************************************************************
   * ========================= UI ELEMENTS =================================
   **************************************************************************/
  const video = document.getElementById('video');
  const startCamBtn = document.getElementById('startCam');
  const stopCamBtn = document.getElementById('stopCam');
  const permissionStatus = document.getElementById('permissionStatus');
  const lastDecoded = document.getElementById('lastDecoded');
  const lastDeviceInfo = document.getElementById('lastDeviceInfo');
  const submitScanBtn = document.getElementById('submitScan');
  const scanMode = document.getElementById('scanMode');
  const signinBtn = document.getElementById('signinBtn');
  const signoutBtn = document.getElementById('signoutBtn');
  const userEmailEl = document.getElementById('user-email');
  const riderInfo = document.getElementById('riderInfo');
  const linkedScooter = document.getElementById('linkedScooter');
  const linkedBattery = document.getElementById('linkedBattery');
  const logList = document.getElementById('logList');
  const refreshLogs = document.getElementById('refreshLogs');

  /**************************************************************************
   * ========================= AUTHENTICATION ===============================
   **************************************************************************/

  signinBtn.addEventListener('click', async () => {
    try{
      signinBtn.disabled = true;
      const provider = new firebase.auth.GoogleAuthProvider();
      await auth.signInWithPopup(provider);
      signinBtn.disabled = false;
    }catch(e){
      console.error('Sign-in failed', e);
      alert('Sign-in failed: '+e.message);
      signinBtn.disabled = false;
    }
  });

  signoutBtn.addEventListener('click', async ()=>{ await auth.signOut(); });

  auth.onAuthStateChanged(async (user)=>{
    if(user){
      userEmailEl.textContent = user.email;
      riderInfo.textContent = `${user.displayName || 'Rider'} (${user.email})`;
      signinBtn.style.display = 'none';
      signoutBtn.style.display = 'inline-block';

      const uDocRef = db.collection('users').doc(user.email);
      const uDoc = await uDocRef.get();
      if(!uDoc.exists){
        await uDocRef.set({
          email: user.email,
          name: user.displayName||null,
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          linkedScooter: null,
          linkedBattery: null
        });
      }
      loadUserDevices();
      loadLogs();
    } else {
      userEmailEl.textContent = 'Not signed in';
      riderInfo.textContent = '—';
      linkedScooter.textContent = '—';
      linkedBattery.textContent = '—';
      signinBtn.style.display = 'inline-block';
      signoutBtn.style.display = 'none';
      logList.innerHTML = '';
    }
  });

  /**************************************************************************
   * ========================= CAMERA & QR SCANNER ==========================
   **************************************************************************/
  let stream = null;
  let scanning = false;
  let scanInterval = null;
  let lastRawResult = null;
  let lastParsedResult = { type: 'unknown', id: '', raw: '' };

  // YANA_CHANGED: Throttle flag to avoid spamming logs for repeated unknown codes during scanning.
  let lastUnknownIdLogged = null; // only log to Firestore when the unknown ID changes

  async function startCamera(){
    try{
      permissionStatus.textContent = 'Requesting camera...';
      stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
      video.srcObject = stream;
      await video.play();
      permissionStatus.textContent = 'Camera active';
      startCamBtn.style.display = 'none';
      stopCamBtn.style.display = 'inline-block';
      scanning = true;
      scanLoop();
    }catch(err){
      console.error('Camera error', err);
      permissionStatus.textContent = 'Camera permission denied or not available';
      alert('Camera access is required for scanning. Please allow camera permissions and try again.');
    }
  }
  function stopCamera(){
    scanning = false;
    permissionStatus.textContent = 'Camera stopped';
    startCamBtn.style.display = 'inline-block';
    stopCamBtn.style.display = 'none';
    if(stream){ stream.getTracks().forEach(t=>t.stop()); stream = null; }
    if(scanInterval){ clearInterval(scanInterval); scanInterval = null; }
  }
  startCamBtn.addEventListener('click', startCamera);
  stopCamBtn.addEventListener('click', stopCamera);

  function scanLoop(){
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    scanInterval = setInterval(async ()=>{
      try{
        if(!scanning || video.readyState !== video.HAVE_ENOUGH_DATA) return;
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.drawImage(video,0,0,canvas.width,canvas.height);
        const imageData = ctx.getImageData(0,0,canvas.width,canvas.height);
        const code = jsQR(imageData.data, imageData.width, imageData.height, {inversionAttempts: "attemptBoth"});
        if(code){
          lastRawResult = code.data.trim();
          lastDecoded.textContent = lastRawResult;
          try {
            const parsed = await determineDeviceType(lastRawResult);
            lastParsedResult = parsed;
            lastDeviceInfo.textContent = parsed.type === 'unknown' ? `UNKNOWN: ${parsed.id}` : `${parsed.type.toUpperCase()}: ${parsed.id}`;
            submitScanBtn.disabled = parsed.type === 'unknown';
            permissionStatus.textContent = parsed.type === 'unknown' ? `Unknown device` : `Detected ${parsed.type} ${parsed.id}`;
            console.log('Parsed QR', parsed);
          } catch (err) {
            console.error('Error determining device type', err);
            permissionStatus.textContent = 'Parse error';
            submitScanBtn.disabled = true;
          }
        }
      }catch(err){
        console.error('Scan loop error', err);
      }
    }, 300);
  }

  /**************************************************************************
   * ========================= SMALL HELPERS ================================
   **************************************************************************/

  // YANA_CHANGED: helper to write structured logs to Firestore from non-transaction flows (errors, unknown_qr).
  async function logOutOfBand(payload){
    try{
      await db.collection('logs').add({
        ts: firebase.firestore.FieldValue.serverTimestamp(),
        ...payload
      });
    }catch(e){
      console.warn('Failed to write log', e);
    }
  }

  /**************************************************************************
   * ========================= PARSING LOGIC ================================
   **************************************************************************/
  async function determineDeviceType(raw) {
    if(!raw) return { type: 'unknown', id: '', raw };

    const rawTrim = raw.trim();
    let id = rawTrim;
    if(rawTrim.includes(':')) {
      const parts = rawTrim.split(':');
      id = parts.slice(1).join(':').trim();
    }
    id = id.toUpperCase();

    const mode = (scanMode && scanMode.value) ? scanMode.value : 'auto';
    if(mode === 'scooter') return { type: 'scooter', id, raw: rawTrim };
    if(mode === 'battery') return { type: 'battery', id, raw: rawTrim };

    try {
      if(/^YEV\d+/i.test(id) || /^SCOT|^SC\d+|^SC[0-9]/i.test(id) || /^SCOOTER/i.test(id) ) {
        return { type: 'scooter', id, raw: rawTrim };
      }
      if(/^YBT\d+/i.test(id) || /^BAT\d+|^BATTERY/i.test(id)) {
        return { type: 'battery', id, raw: rawTrim };
      }
    } catch (e) {
      console.warn('Heuristic check failed', e);
    }

    try {
      const scooterRef = db.collection('devices').doc(`scooter_${id}`);
      const batteryRef = db.collection('devices').doc(`battery_${id}`);
      const [sSnap, bSnap] = await Promise.all([scooterRef.get(), batteryRef.get()]);
      if(sSnap.exists){ return { type: 'scooter', id, raw: rawTrim, source: 'devices_collection' }; }
      if(bSnap.exists){ return { type: 'battery', id, raw: rawTrim, source: 'devices_collection' }; }

      // YANA_CHANGED: log unknown QR once per ID (throttled) so we can trace bad stickers/prints.
      if(lastUnknownIdLogged !== id){
        lastUnknownIdLogged = id;
        const u = auth.currentUser;
        logOutOfBand({
          email: u ? u.email : null,
          action: 'unknown_qr',
          deviceType: 'unknown',
          deviceId: id,
          rawPayload: rawTrim
        });
        console.warn('Unknown device id scanned:', id);
        permissionStatus.textContent = `Unknown QR: ${id}`;
      }
      return { type: 'unknown', id, raw: rawTrim };
    } catch (err) {
      console.error('Firestore lookup failed when determining device type', err);
      return { type: 'unknown', id, raw: rawTrim };
    }
  }

  /**************************************************************************
   * ========================= SUBMIT / REGISTER LOGIC ======================
   **************************************************************************/
  // YANA_CHANGED: ensure we always re-enable the Submit button and write an error log on failure.
  submitScanBtn.addEventListener('click', async ()=>{
    const user = auth.currentUser;
    if(!user){ alert('Please sign in with Google first.'); return; }
    if(!lastRawResult){ alert('No QR code scanned yet. Please scan and then submit.'); return; }

    let parsed = lastParsedResult && lastParsedResult.raw === lastRawResult ? lastParsedResult : await determineDeviceType(lastRawResult);
    if(parsed.type === 'unknown'){
      alert('Unknown device type. Use the scan-mode dropdown to force scooter or battery.');
      return;
    }

    permissionStatus.textContent = 'Processing...';
    submitScanBtn.disabled = true;
    try{
      let note = '';
      if(parsed.type === 'scooter'){
        note = await handleScooterScan(user.email, parsed.id, parsed.raw);
      } else if(parsed.type === 'battery'){
        note = await handleBatteryScan(user.email, parsed.id, parsed.raw);
      }
      permissionStatus.textContent = note ? `Done — ${note}` : 'Done';
      loadUserDevices();
      loadLogs();
    }catch(e){
      permissionStatus.textContent = 'Error';
      alert('Operation failed: ' + (e && e.message ? e.message : e));
      console.error(e);
      // YANA_CHANGED: persist error to logs for audit/debug
      await logOutOfBand({
        email: user.email,
        action: 'error',
        deviceType: parsed.type,
        deviceId: parsed.id,
        rawPayload: parsed.raw,
        message: e && e.message ? e.message : String(e)
      });
    } finally {
      // YANA_CHANGED: ensure button is always re-enabled in every path
      submitScanBtn.disabled = false;
    }
  });

  /**
   * YANA_RULE: Fix Firestore transaction order + flow.
   */
  function safeUpdateOrCreate(tx, ref, data) {
    tx.set(ref, data, { merge: true });
  }

  // YANA_RULE: FIXED brace/flow so all logic is OUTSIDE the battery-read block.
  async function handleScooterScan(email, scooterId, rawPayload){
    const userRef = db.collection('users').doc(email);
    const scootyRef = db.collection('scooters').doc(scooterId);
    const logsRef = db.collection('logs');

    // YANA_CHANGED: summary message to surface auto-heal or action info back to UI
    let summary = '';

    await db.runTransaction(async (tx)=>{
      // READS FIRST
      const userSnap = await tx.get(userRef);
      if(!userSnap.exists) throw new Error('User doc missing');
      const user = userSnap.data();

      const scootySnap = await tx.get(scootyRef);
            const scootySnap = await tx.get(scootyRef);
      let scooty;
      if (!scootySnap.exists) {
        // YANA_CHANGED: Create scooter doc if missing, with full schema
        scooty = {
          scootyId: scooterId,
          currentBatteryId: null,
          currentRiderEmail: null,
          status: 'free'
        };
        tx.set(scootyRef, scooty); 
      } else {
        scooty = scootySnap.data();
      }

      // YANA_CHANGED: Enforce exclusivity
      if (scooty.currentRiderEmail && scooty.currentRiderEmail !== email) {
        throw new Error("This scooter is already assigned to another rider.");
      }


      let batteryRef = null, batterySnap = null, battery = null;
      if(scooty.currentBatteryId){
        batteryRef = db.collection('batteries').doc(scooty.currentBatteryId);
        batterySnap = await tx.get(batteryRef);
        battery = batterySnap.exists ? batterySnap.data() : null;
      } // YANA_RULE: <-- close the battery read block properly

      // YANA_CHANGED: Auto-heal — scooter has a battery but no rider (violates rule "no scooter-battery link without a rider").
      if(!scooty.currentRiderEmail && scooty.currentBatteryId){
        if(batteryRef){
          safeUpdateOrCreate(tx, batteryRef, { assignedScootyId: null, assignedRiderEmail: null });
        }
        tx.set(scootyRef, { currentBatteryId:null }, { merge:true });
        tx.set(logsRef.doc(), {ts:firebase.firestore.FieldValue.serverTimestamp(),email,action:'autoheal',deviceType:'scooter',deviceId:scooterId,rawPayload, note:'cleared battery link on riderless scooter'});
        summary += (summary?'; ':'') + 'Auto-healed: riderless scooter had battery';
      }

      // FLOW: returning scooter if rider already holds this scooter
      if(user.linkedScooter === scooterId){
        // Precondition per spec: scooter must have a battery to perform "scooter return (with battery)"
        if(!scooty.currentBatteryId){
          // YANA_CHANGED: Log invariant violation clearly and abort
          tx.set(logsRef.doc(), {ts:firebase.firestore.FieldValue.serverTimestamp(),email,action:'error_missing_battery_on_return',deviceType:'scooter',deviceId:scooterId,rawPayload});
          throw new Error("Scooter return requires the scooter to have a battery linked.");
        }
        // Clear Rider + Scooter + Battery links together
        safeUpdateOrCreate(tx, userRef, { linkedScooter: null, linkedBattery: null });
        tx.set(scootyRef, { currentRiderEmail:null, currentBatteryId:null, status:'free' }, { merge:true });
        if(batteryRef){
          safeUpdateOrCreate(tx, batteryRef, { assignedScootyId: null, assignedRiderEmail: null, status:'free' });
        }
        tx.set(logsRef.doc(), {ts:firebase.firestore.FieldValue.serverTimestamp(),email,action:'return_scooter',deviceType:'scooter',deviceId:scooterId,rawPayload});
        summary += (summary?'; ':'') + 'Returned scooter with battery';
        return;
      }

      // Enforce: rider can’t take another scooter
      if(user.linkedScooter && user.linkedScooter !== scooterId){
        throw new Error("Please return your current scooter first.");
      }

      // Enforce: scooter not already assigned to different rider
      if(scooty.currentRiderEmail && scooty.currentRiderEmail !== email){
        throw new Error("This scooter is already assigned to a different rider.");
      }

      // Assign rider ↔ scooter
      safeUpdateOrCreate(userRef, { linkedScooter:scooterId });
      tx.set(scootyRef, { currentRiderEmail:email, /* battery stays as-is or null */ status:'assigned' }, { merge:true });
      tx.set(logsRef.doc(), {ts:firebase.firestore.FieldValue.serverTimestamp(),email,action:'assign_scooter',deviceType:'scooter',deviceId:scooterId,rawPayload});
      summary += (summary?'; ':'') + 'Assigned scooter';
    });

    return summary;
  }

  // YANA_RULE: define scootyRef/scootySnap when needed; delink battery even if scooter missing.
  async function handleBatteryScan(email, batteryId, rawPayload){
    const userRef = db.collection('users').doc(email);
    const batteryRef = db.collection('batteries').doc(batteryId);
    const logsRef = db.collection('logs');

    // YANA_CHANGED: summary message to surface auto-heal or action info back to UI
    let summary = '';

    await db.runTransaction(async (tx)=>{
      // READS FIRST
      const userSnap = await tx.get(userRef);
      if(!userSnap.exists) throw new Error('User doc missing');
      const user = userSnap.data();

      const batterySnap = await tx.get(batteryRef);
      const battery = batterySnap.exists ? batterySnap.data() : { assignedScootyId:null, assignedRiderEmail:null, status:'free' };

      let scootyRef = null, scootySnap = null, scooty = null;
      if(user.linkedScooter){
        scootyRef = db.collection('scooters').doc(user.linkedScooter);
        scootySnap = await tx.get(scootyRef);
        scooty = scootySnap.exists ? scootySnap.data() : { currentBatteryId:null, currentRiderEmail:email, status:'assigned' };
      }

      // YANA_CHANGED: Auto-heal a battery linked to a scooter that has no rider.
      if(battery.assignedScootyId && (!battery.assignedRiderEmail || battery.assignedRiderEmail === email)){
        const otherScootRef = db.collection('scooters').doc(battery.assignedScootyId);
        const otherScootSnap = await tx.get(otherScootRef);
        const otherScoot = otherScootSnap.exists ? otherScootSnap.data() : null;

        if(otherScoot && !otherScoot.currentRiderEmail){
          // detach from riderless scooter
          safeUpdateOrCreate(tx, batteryRef, { assignedScootyId:null, assignedRiderEmail:null, status:'free' });
          if(otherScoot.currentBatteryId === batteryId){
            tx.set(otherScootRef, { currentBatteryId:null }, { merge:true });
          }
          tx.set(logsRef.doc(), {ts:firebase.firestore.FieldValue.serverTimestamp(),email,action:'autoheal',deviceType:'battery',deviceId:batteryId,rawPayload, note:'cleared from riderless scooter'});
          summary += (summary?'; ':'') + 'Auto-healed: battery was linked to riderless scooter';
          // Refresh local battery state to "free" for subsequent checks
          battery.assignedScootyId = null;
          battery.assignedRiderEmail = null;
          battery.status = 'free';
        }
      }

      // FLOW: returning same battery (toggle off)
      if(user.linkedBattery === batteryId){
        tx.update(userRef, { linkedBattery:null });
        safeUpdateOrCreate(tx, batteryRef, { assignedScootyId: null, assignedRiderEmail: null, status:'free' });
        if(scootyRef && scootySnap && scootySnap.exists){
          tx.update(scootyRef, { currentBatteryId:null, status:'assigned' });
        }
        tx.set(logsRef.doc(), {ts:firebase.firestore.FieldValue.serverTimestamp(),email,action:'return_battery',deviceType:'battery',deviceId:batteryId,rawPayload});
        summary += (summary?'; ':'') + 'Returned battery';
        return;
      }

      // Preconditions: rider must have a scooter
      if(!user.linkedScooter){
        throw new Error("You must have a scooter before taking a battery.");
      }

      // Enforce: rider can only have one battery at a time
      if(user.linkedBattery && user.linkedBattery !== batteryId){
        throw new Error("Please return your current battery first.");
      }

      // Enforce: battery not already in use by another rider/scooter
      if(battery.assignedRiderEmail && battery.assignedRiderEmail !== email){
        throw new Error("This battery is already assigned to another rider.");
      }
      if(battery.assignedScootyId && battery.assignedScootyId !== user.linkedScooter){
        throw new Error("This battery is already assigned to a different scooter.");
      }

      // Conflict resolution: scooter already has a different battery; we auto-heal by clearing that old battery.
      if(scooty && scooty.currentBatteryId && scooty.currentBatteryId !== batteryId){
        const oldBattId = scooty.currentBatteryId;
        const oldBattRef = db.collection('batteries').doc(oldBattId);
        const oldBattSnap = await tx.get(oldBattRef);
        if(oldBattSnap.exists){
          const oldBatt = oldBattSnap.data();
          // Clean old battery links
          safeUpdateOrCreate(tx, oldBattRef, { assignedScootyId:null, assignedRiderEmail:null, status:'free' });
        }
        tx.update(scootyRef, { currentBatteryId:null });
        tx.set(logsRef.doc(), {ts:firebase.firestore.FieldValue.serverTimestamp(),email,action:'autoheal',deviceType:'scooter',deviceId:user.linkedScooter,rawPayload, note:`cleared previous battery ${oldBattId} from scooter before assigning new one`});
        summary += (summary?'; ':'') + `Auto-healed: scooter had old battery ${oldBattId}`;
      }

      // Assign battery ↔ rider ↔ scooter
      safeUpdateOrCreate(tx, userRef, { linkedBattery:batteryId });
      tx.set(batteryRef, { assignedScootyId:user.linkedScooter, assignedRiderEmail:email, status:'assigned' }, { merge:true });
      if(scootyRef){ safeUpdateOrCreate(tx, scootyRef, { currentBatteryId:batteryId }); }
      tx.set(logsRef.doc(), {ts:firebase.firestore.FieldValue.serverTimestamp(),email,action:'assign_battery',deviceType:'battery',deviceId:batteryId,rawPayload});
      summary += (summary?'; ':'') + 'Assigned battery';
    });

    return summary;
  }

  /**************************************************************************
   * ========================= UI: load user & logs =========================
   **************************************************************************/
  async function loadUserDevices(){
    const user = auth.currentUser;
    if(!user) return;
    const uDoc = await db.collection('users').doc(user.email).get();
    const data = uDoc.exists ? uDoc.data() : null;
    linkedScooter.textContent = data && data.linkedScooter ? data.linkedScooter : '—';
    linkedBattery.textContent = data && data.linkedBattery ? data.linkedBattery : '—';
  }

  async function loadLogs(){
    logList.innerHTML = `<div class="muted">Loading logs...</div>`;
    const q = db.collection('logs').orderBy('ts','desc').limit(50);
    const snap = await q.get();
    logList.innerHTML = '';
    if(snap.empty){
      logList.innerHTML = '<div class="muted">No logs yet</div>';
      return;
    }
    snap.forEach(doc=>{
      const d = doc.data();
      const when = d.ts ? new Date(d.ts.toDate()).toLocaleString() : '—';
      const el = document.createElement('div');
      el.className = 'log-item';
      el.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center">
        <div><strong>${d.action ? d.action.toUpperCase() : 'LOG'}</strong> &nbsp; ${d.deviceType || ''} <span style="opacity:.9">(${d.deviceId || ''})</span></div>
        <div class="muted" style="font-size:12px">${when}</div>
      </div>
      <div class="muted" style="margin-top:6px">user: ${d.email || '—'} • payload: <code>${escapeHtml(d.rawPayload || '')}</code>${d.note ? ' • note: '+escapeHtml(d.note) : ''}</div>`;
      logList.appendChild(el);
    });
  }
  refreshLogs.addEventListener('click', loadLogs);

  function escapeHtml(s){ return (s+'').replace(/[&<>"]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

  window.addEventListener('beforeunload', ()=>{ if(stream) stream.getTracks().forEach(t=>t.stop()); });

  (async ()=>{ /* onAuthStateChanged handles initial UI */ })();
  </script>
</body>
</html>
