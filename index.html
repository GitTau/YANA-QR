<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Yana QR - Rider Register</title>

  <!-- ========== STYLES (kept light) ========== -->
  <style>
    :root{
      --bg:#000; --action:#00eaff; --muted:#9aa6ac; --glass:rgba(255,255,255,0.06);
      --radius:14px; font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:#fff;}
    *{box-sizing:border-box}
    .container{max-width:1100px;margin:28px auto;padding:24px}
    header{display:flex;align-items:center;gap:14px;margin-bottom:18px}
    .brand{font-size:18px;font-weight:700} .sub{font-size:12px;color:var(--muted)}
    .top-actions{margin-left:auto;display:flex;gap:10px;align-items:center}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding:16px;border-radius:var(--radius);box-shadow:0 6px 24px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.03)}
    .btn{background:var(--action);border:none;color:#001;padding:9px 14px;border-radius:12px;font-weight:700;cursor:pointer;box-shadow:0 6px 18px rgba(0,234,255,0.12)}
    .btn.ghost{background:transparent;border:1px solid var(--glass);color:var(--muted);font-weight:600}
    .small{font-size:13px;padding:8px 10px;border-radius:10px}
    .grid{display:grid;grid-template-columns:1fr 420px;gap:14px}
    @media(max-width:960px){ .grid{grid-template-columns:1fr} }
    .scanner{display:flex;flex-direction:column;gap:10px}
    video#video{width:100%;border-radius:12px;background:#000;height:360px;object-fit:cover;border:1px solid rgba(255,255,255,0.06)}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    .status{padding:8px;border-radius:10px;background:rgba(255,255,255,0.05);color:var(--muted);font-size:13px}
    .info-row{display:flex;gap:10px;align-items:center;justify-content:space-between;margin-top:8px}
    .log-list{max-height:380px;overflow:auto;margin-top:8px;padding-right:6px}
    .log-item{padding:10px;border-radius:10px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.04);margin-bottom:8px;font-size:13px}
    .muted{color:var(--muted);font-size:13px}
    .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:#121212;border:1px solid rgba(255,255,255,0.08);padding:10px 14px;border-radius:10px;font-size:13px}
  </style>
</head>

<body>
  <div class="container">
    <!-- HEADER -->
    <header>
      <img src="logo.svg" alt="App Logo" style="height:28px;width:auto"/>
      <div>
        <div class="brand">Yana — Rider QR</div>
        <div class="sub">Scan · Register · Log</div>
      </div>
      <div class="top-actions">
        <div id="user-email" class="muted">Not signed in</div>
        <button id="signinBtn" class="btn small">Sign in with Google</button>
        <button id="signoutBtn" class="btn small ghost" style="display:none">Sign out</button>
      </div>
    </header>

    <div class="grid">
      <!-- LEFT: Scanner + controls -->
      <section class="card scanner">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">Start Scanning</div>
        </div>

        <!-- Single video element (fixed duplication bug) -->
        <video id="video" playsinline></video>

        <!-- controls -->
        <div class="controls">
          <button id="startCam" class="btn small">Start Camera</button>
          <button id="stopCam" class="btn small ghost" style="display:none">Stop Camera</button>

          <!-- Optional user override if needed -->
          <select id="scanMode" class="small" style="background:transparent;border:1px solid rgba(255,255,255,0.08);color:#fff;padding:8px;border-radius:10px">
            <option value="auto">Auto-detect (Scooty/Battery)</option>
            <option value="scooty">Force: Scooty</option>
            <option value="battery">Force: Battery</option>
          </select>

          <div id="permissionStatus" class="status">Camera idle</div>
        </div>

        <!-- last scan + action -->
        <div class="info-row">
          <div>
            <div class="muted">Last decoded</div>
            <div id="lastDecoded" style="font-weight:700">—</div>
            <div class="muted" id="lastDeviceInfo">—</div>
          </div>
          <div style="text-align:right">
            <button id="submitScan" class="btn small" disabled>Submit</button>
            <div class="muted" style="margin-top:6px;font-size:12px">Scan → Submit</div>
          </div>
        </div>

        <div class="muted" style="margin-top:8px;font-size:13px">
          Tip: QR payloads like <code>scooty:SC001</code> or <code>battery:BAT100</code> work best. Plain IDs are auto-detected in Firestore.
        </div>
      </section>

      <!-- RIGHT: summary, device status, logs -->
      <aside class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">Rider & Devices</div>
        </div>

        <div style="margin-top:12px">
          <div class="muted">Signed-in rider</div>
          <div id="riderInfo" style="font-weight:700;margin-top:6px">—</div>

          <div style="margin-top:12px" class="muted">Linked scooty</div>
          <div id="linkedScooter" style="font-weight:700;margin-top:6px">—</div>

          <div style="margin-top:12px" class="muted">Linked battery</div>
          <div id="linkedBattery" style="font-weight:700;margin-top:6px">—</div>
        </div>

        <hr style="border:none;border-top:1px solid rgba(255,255,255,0.06);margin:14px 0">

        <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
          <div style="font-weight:700">Recent logs</div>
          <button id="refreshLogs" class="btn small ghost">Refresh</button>
        </div>

        <div class="log-list" id="logList"></div>
      </aside>
    </div>

    <footer class="muted" style="margin-top:12px">Built for Yana — riders & devices tracked with Firestore transactions.</footer>
  </div>

  <div id="toast" class="toast" style="display:none"></div>

  <!-- ========== SCRIPTS ========== -->
  <!-- Firebase JS SDKs (compat to minimize churn) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  <!-- QR decoding -->
  <script src="https://unpkg.com/jsqr/dist/jsQR.js"></script>

  <script>
  /**************************************************************************
   * ========================= FIREBASE CONFIG ==============================
   * Uses your existing project. Keep compat API to avoid breaking changes.
   **************************************************************************/
  const firebaseConfig = {
    apiKey: "AIzaSyCP7KKqJhtauDVonZ-6ApHRitu7CCdV0Ns",
    authDomain: "yana-qr.firebaseapp.com",
    projectId: "yana-qr",
    storageBucket: "yana-qr.firebasestorage.app",
    messagingSenderId: "905613005387",
    appId: "1:905613005387:web:b0d8464d826972654b73ce",
    measurementId: "G-9P9DLJGQHQ"
  };
  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.firestore();

  /**************************************************************************
   * ========================= UI ELEMENTS =================================
   **************************************************************************/
  const video = document.getElementById('video');
  const startCamBtn = document.getElementById('startCam');
  const stopCamBtn = document.getElementById('stopCam');
  const permissionStatus = document.getElementById('permissionStatus');
  const lastDecoded = document.getElementById('lastDecoded');
  const lastDeviceInfo = document.getElementById('lastDeviceInfo');
  const submitScanBtn = document.getElementById('submitScan');
  const scanMode = document.getElementById('scanMode');
  const signinBtn = document.getElementById('signinBtn');
  const signoutBtn = document.getElementById('signoutBtn');
  const userEmailEl = document.getElementById('user-email');
  const riderInfo = document.getElementById('riderInfo');
  const linkedScooter = document.getElementById('linkedScooter');
  const linkedBattery = document.getElementById('linkedBattery');
  const logList = document.getElementById('logList');
  const refreshLogs = document.getElementById('refreshLogs');
  const toastEl = document.getElementById('toast');

  /**************************************************************************
   * ========================= AUTHENTICATION ===============================
   * On first sign-in we ensure a user doc exists (Rider Master subset).
   **************************************************************************/
  signinBtn.addEventListener('click', async () => {
    try{
      signinBtn.disabled = true;
      const provider = new firebase.auth.GoogleAuthProvider();
      await auth.signInWithPopup(provider);
    }catch(e){
      showToast('Sign-in failed: ' + e.message);
    }finally{
      signinBtn.disabled = false;
    }
  });

  signoutBtn.addEventListener('click', async ()=> { await auth.signOut(); });

  auth.onAuthStateChanged(async (user)=>{
    if(user){
      userEmailEl.textContent = user.email;
      riderInfo.textContent = `${user.displayName || 'Rider'} (${user.email})`;
      signinBtn.style.display = 'none';
      signoutBtn.style.display = 'inline-block';

      // Ensure user doc exists with expected fields
      const uRef = db.collection('users').doc(user.email);
      const uSnap = await uRef.get();
      if(!uSnap.exists){
        await uRef.set({
          email: user.email,
          name: user.displayName || null,
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
          linkedScooter: null,
          linkedBattery: null
        });
      }
      await loadUserDevices();
      await loadLogs();
    } else {
      userEmailEl.textContent = 'Not signed in';
      riderInfo.textContent = '—';
      linkedScooter.textContent = '—';
      linkedBattery.textContent = '—';
      signinBtn.style.display = 'inline-block';
      signoutBtn.style.display = 'none';
      logList.innerHTML = '';
    }
  });

  /**************************************************************************
   * ========================= CAMERA & SCANNER =============================
   * Simple jsQR loop. Submit button only enabled on successful decode.
   **************************************************************************/
  let stream = null;
  let scanning = false;
  let scanInterval = null;
  let lastRawResult = null;

  async function startCamera(){
    try{
      permissionStatus.textContent = 'Requesting camera...';
      stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
      video.srcObject = stream;
      await video.play();
      permissionStatus.textContent = 'Camera active';
      startCamBtn.style.display = 'none';
      stopCamBtn.style.display = 'inline-block';
      scanning = true;
      scanLoop();
    }catch(err){
      console.error(err);
      permissionStatus.textContent = 'Camera permission denied or not available';
      showToast('Allow camera access to scan QRs.');
    }
  }
  function stopCamera(){
    scanning = false;
    permissionStatus.textContent = 'Camera stopped';
    startCamBtn.style.display = 'inline-block';
    stopCamBtn.style.display = 'none';
    if(stream){ stream.getTracks().forEach(t=>t.stop()); stream = null; }
    if(scanInterval){ clearInterval(scanInterval); scanInterval = null; }
  }
  startCamBtn.addEventListener('click', startCamera);
  stopCamBtn.addEventListener('click', stopCamera);

  function scanLoop(){
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    scanInterval = setInterval(()=>{
      if(!scanning || video.readyState !== video.HAVE_ENOUGH_DATA) return;
      canvas.width = video.videoWidth; canvas.height = video.videoHeight;
      ctx.drawImage(video,0,0,canvas.width,canvas.height);
      const imageData = ctx.getImageData(0,0,canvas.width,canvas.height);
      const code = jsQR(imageData.data, imageData.width, imageData.height, {inversionAttempts: "attemptBoth"});
      if(code){
        lastRawResult = (code.data||'').trim();
        lastDecoded.textContent = lastRawResult || '—';
        submitScanBtn.disabled = !lastRawResult;
        lastDeviceInfo.textContent = 'Ready to submit';
        permissionStatus.textContent = 'QR detected';
      }
    }, 300);
  }

  window.addEventListener('beforeunload', ()=>{ if(stream) stream.getTracks().forEach(t=>t.stop()); });

  /**************************************************************************
   * ========================= HELPER: TOAST ================================
   **************************************************************************/
  let toastTimer = null;
  function showToast(msg){
    toastEl.textContent = msg;
    toastEl.style.display = 'block';
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=> toastEl.style.display = 'none', 2800);
  }

  /**************************************************************************
   * ========================= QR PAYLOAD PARSER ============================
   * Supports:
   *  - "scooty:SC001" / "battery:BAT100" (case-insensitive)
   *  - Plain IDs → we probe Firestore to resolve type.
   **************************************************************************/
  function normalizeId(s){ return (s||'').trim().toUpperCase(); }

  async function resolveTypeAndId(raw, forcedMode){
    // 1) If forced by dropdown (user override), trust it.
    if(forcedMode === 'scooty') return { type:'scooty', id: normalizeId(raw.replace(/^scooty\s*:/i,'')) };
    if(forcedMode === 'battery') return { type:'battery', id: normalizeId(raw.replace(/^battery\s*:/i,'')) };

    // 2) Try explicit prefixes first
    const prefixed = raw.trim();
    const m1 = prefixed.match(/^scooty\s*:\s*(.+)$/i);
    if(m1) return { type:'scooty', id: normalizeId(m1[1]) };
    const m2 = prefixed.match(/^battery\s*:\s*(.+)$/i);
    if(m2) return { type:'battery', id: normalizeId(m2[1]) };

    // 3) Fallback: probe masters by ID (lightweight gets)
    const probeId = normalizeId(prefixed);
    // Try scooty
    const scootySnap = await db.collection('scooties').doc(probeId).get();
    if(scootySnap.exists) return { type:'scooty', id: probeId };
    // Try battery
    const batterySnap = await db.collection('batteries').doc(probeId).get();
    if(batterySnap.exists) return { type:'battery', id: probeId };

    return { type:'unknown', id: probeId };
  }

  /**************************************************************************
   * ========================= CORE: CLOSED-LOOP FLOWS ======================
   * All operations are single Firestore transactions that enforce rules:
   * 2.1..2.6, 3.1..3.2, 4.1..4.3
   *
   * Collections:
   *  - users/{email}                 (Rider Master subset)
   *  - scooties/{scootyId}          fields: currentBatteryId, currentRiderEmail, status, lastUpdated
   *  - batteries/{batteryId}        fields: assignedScootyId, assignedRiderEmail, status, lastUpdated
   **************************************************************************/

  // Utility: ensure master docs exist (lazy creation) with neutral defaults.
  function baseScootyDoc(scootyId){
    return {
      scootyId,
      currentBatteryId: null,
      currentRiderEmail: null,
      status: 'active',
      lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
    };
  }
  function baseBatteryDoc(batteryId){
    return {
      batteryId,
      assignedScootyId: null,
      assignedRiderEmail: null,
      status: 'available',
      lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
    };
  }

  // Invariant checks (Rule 2.6): throws Error if violated
  function assertConsistency({u, s, b}){
    // User ↔ Scooty
    if((u.linkedScooter || null) !== (s.currentRiderEmail === u.email ? s.scootyId : (u.linkedScooter||null))){
      // When rider is linked to a scooty, scooty must point back to rider and same scootyId
      if(u.linkedScooter){
        if(!s || s.scootyId !== u.linkedScooter || s.currentRiderEmail !== u.email){
          throw new Error('Data mismatch: rider↔scooty link inconsistent.');
        }
      }
    }
    // User ↔ Battery
    if(u.linkedBattery){
      if(!b || b.batteryId !== u.linkedBattery || b.assignedRiderEmail !== u.email){
        throw new Error('Data mismatch: rider↔battery link inconsistent.');
      }
    }
    // Scooty ↔ Battery (1 battery per scooty, and battery points back)
    if(s.currentBatteryId){
      if(!b || b.batteryId !== s.currentBatteryId || b.assignedScootyId !== s.scootyId){
        throw new Error('Data mismatch: scooty↔battery link inconsistent.');
      }
    }
    if(b.assignedScootyId){
      if(!s || s.scootyId !== b.assignedScootyId || s.currentBatteryId !== b.batteryId){
        throw new Error('Data mismatch: battery↔scooty link inconsistent.');
      }
    }
  }

  // Assign a scooty to rider (Rule 3.1)
  async function assignScootyTx(email, scootyId){
    const uRef = db.collection('users').doc(email);
    const sRef = db.collection('scooties').doc(scootyId);

    await db.runTransaction(async (tx)=>{
      const [uSnap, sSnap] = await Promise.all([tx.get(uRef), tx.get(sRef)]);
      if(!uSnap.exists) throw new Error('User doc missing.');
      const u = uSnap.data();

      if(u.linkedScooter) throw new Error(`You already hold scooty ${u.linkedScooter}. Return it first.`);

      let s = sSnap.exists ? sSnap.data() : baseScootyDoc(scootyId);

      if(s.currentRiderEmail && s.currentRiderEmail !== email){
        throw new Error(`Scooty ${scootyId} is already assigned to ${s.currentRiderEmail}.`);
      }

      // Process: link rider on scooty; retain existing battery if any
      s.currentRiderEmail = email;
      s.lastUpdated = firebase.firestore.FieldValue.serverTimestamp();

      tx.set(sRef, s, {merge:true});
      tx.update(uRef, {
        linkedScooter: scootyId,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      });

      // If user had a battery linked (should not per 2.1 same-type rule), allowed—battery is separate entity.
      // Logging
      tx.set(db.collection('logs').doc(), {
        ts: firebase.firestore.FieldValue.serverTimestamp(),
        email, action:'register', deviceType:'scooty', deviceId:scootyId, rawPayload:`scooty:${scootyId}`
      });

      // Optional consistency assert (post)
      const bId = s.currentBatteryId;
      if(bId){
        const bRef = db.collection('batteries').doc(bId);
        const bSnap = await tx.get(bRef);
        if(bSnap.exists){
          const b = bSnap.data();
          // If a battery is mounted, it must point back to the scooty (Rule 2.2/2.3)
          if(b.assignedScootyId && b.assignedScootyId !== s.scootyId){
            throw new Error('Consistency issue: mounted battery points to another scooty.');
          }
        }
      }
    });
  }

  // Return scooty (Rule 4.1)
  async function returnScootyTx(email, scootyId){
    const uRef = db.collection('users').doc(email);
    const sRef = db.collection('scooties').doc(scootyId);

    await db.runTransaction(async (tx)=>{
      const [uSnap, sSnap] = await Promise.all([tx.get(uRef), tx.get(sRef)]);
      if(!uSnap.exists) throw new Error('User doc missing.');
      const u = uSnap.data();
      if(u.linkedScooter !== scootyId) throw new Error('This scooty is not assigned to you.');

      if(!sSnap.exists) throw new Error('Scooty record missing.');
      const s = sSnap.data();

      // Preconditions: scooty must have a battery (Rule 2.4)
      if(!s.currentBatteryId){
        throw new Error('Scooty return blocked: attach/retain its battery before returning.');
      }

      // Process: clear rider from scooty (keep battery); clear rider in battery (keep scooty)
      const bRef = db.collection('batteries').doc(s.currentBatteryId);
      const bSnap = await tx.get(bRef);
      if(!bSnap.exists) throw new Error('Battery record missing.');
      const b = bSnap.data();

      // Battery must belong to same scooty
      if(b.assignedScootyId !== scootyId){
        throw new Error('Inconsistency: battery is not linked to this scooty.');
      }

      // Clear rider on both, keep scooty-battery linkage
      s.currentRiderEmail = null;
      s.lastUpdated = firebase.firestore.FieldValue.serverTimestamp();
      b.assignedRiderEmail = null;
      b.lastUpdated = firebase.firestore.FieldValue.serverTimestamp();

      tx.update(sRef, s);
      tx.update(bRef, b);

      // Rider holds neither scooty nor battery after return (Rule 4.1.3)
      tx.update(uRef, {
        linkedScooter: null,
        linkedBattery: null,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      });

      tx.set(db.collection('logs').doc(), {
        ts: firebase.firestore.FieldValue.serverTimestamp(),
        email, action:'deregister', deviceType:'scooty', deviceId:scootyId, rawPayload:`scooty:${scootyId}`
      });
    });
  }

  // Assign battery (Rule 3.2)
  async function assignBatteryTx(email, batteryId){
    const uRef = db.collection('users').doc(email);
    const bRef = db.collection('batteries').doc(batteryId);

    await db.runTransaction(async (tx)=>{
      const uSnap = await tx.get(uRef);
      if(!uSnap.exists) throw new Error('User doc missing.');
      const u = uSnap.data();

      if(!u.linkedScooter) throw new Error('Assign a scooty first before assigning a battery.');
      if(u.linkedBattery) throw new Error(`You already hold battery ${u.linkedBattery}. Return it first.`);

      // Resolve rider's scooty
      const sRef = db.collection('scooties').doc(u.linkedScooter);
      const sSnap = await tx.get(sRef);
      let s = sSnap.exists ? sSnap.data() : baseScootyDoc(u.linkedScooter);

      // If scooty already has a battery, block (Rule 2.2)
      if(s.currentBatteryId){
        throw new Error(`Your scooty already has battery ${s.currentBatteryId}. Return it first.`);
      }

      // Battery doc
      const bSnap = await tx.get(bRef);
      let b = bSnap.exists ? bSnap.data() : baseBatteryDoc(batteryId);

      // If battery is already linked → only allow if it belongs to THIS rider's scooty (Rule 3.2.1.2.1)
      if(b.assignedScootyId && b.assignedScootyId !== s.scootyId){
        throw new Error('This battery belongs to another scooty. Please return your current battery first.');
      }
      if(b.assignedRiderEmail && b.assignedRiderEmail !== email){
        throw new Error('This battery is held by another rider.');
      }

      // Process: link battery to scooty and rider; update user & scooty
      b.assignedScootyId = s.scootyId || u.linkedScooter; // ensure field exists
      b.assignedRiderEmail = email;
      b.lastUpdated = firebase.firestore.FieldValue.serverTimestamp();

      s.scootyId = s.scootyId || u.linkedScooter; // normalize if created
      s.currentBatteryId = batteryId;
      s.lastUpdated = firebase.firestore.FieldValue.serverTimestamp();

      tx.set(bRef, b, {merge:true});
      tx.set(sRef, s, {merge:true});
      tx.update(uRef, {
        linkedBattery: batteryId,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      });

      tx.set(db.collection('logs').doc(), {
        ts: firebase.firestore.FieldValue.serverTimestamp(),
        email, action:'register', deviceType:'battery', deviceId:batteryId, rawPayload:`battery:${batteryId}`
      });
    });
  }

  // Return battery (Rule 4.2, 4.3)
  async function returnBatteryTx(email, batteryId){
    const uRef = db.collection('users').doc(email);
    const bRef = db.collection('batteries').doc(batteryId);

    await db.runTransaction(async (tx)=>{
      const uSnap = await tx.get(uRef);
      if(!uSnap.exists) throw new Error('User doc missing.');
      const u = uSnap.data();

      if(!u.linkedScooter) throw new Error('You must have a scooty to return its battery.');
      if(u.linkedBattery !== batteryId) throw new Error('This is not your linked battery.');

      // Resolve scooty
      const sRef = db.collection('scooties').doc(u.linkedScooter);
      const sSnap = await tx.get(sRef);
      if(!sSnap.exists) throw new Error('Scooty record missing.');
      const s = sSnap.data();

      // Preconditions: scanned battery must be the battery currently linked to the rider's scooty (4.2.1.1)
      if(s.currentBatteryId !== batteryId){
        throw new Error('Scan the battery currently linked to your scooty.');
      }

      // Battery record
      const bSnap = await tx.get(bRef);
      if(!bSnap.exists) throw new Error('Battery record missing.');
      const b = bSnap.data();

      // Battery cannot belong to another scooty (4.2.1.2)
      if(b.assignedScootyId && b.assignedScootyId !== s.scootyId){
        throw new Error('This battery is linked to another scooty. Cannot return.');
      }

      // Process: clear links on battery; clear battery on scooty; keep rider on scooty
      b.assignedScootyId = null;
      b.assignedRiderEmail = null;
      b.lastUpdated = firebase.firestore.FieldValue.serverTimestamp();

      s.currentBatteryId = null;
      s.lastUpdated = firebase.firestore.FieldValue.serverTimestamp();

      tx.update(bRef, b);
      tx.update(sRef, s);
      tx.update(uRef, {
        linkedBattery: null,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      });

      tx.set(db.collection('logs').doc(), {
        ts: firebase.firestore.FieldValue.serverTimestamp(),
        email, action:'deregister', deviceType:'battery', deviceId:batteryId, rawPayload:`battery:${batteryId}`
      });
    });
  }

  /**************************************************************************
   * ========================= ROUTER: SUBMIT HANDLER =======================
   * Decides whether a scan means "assign" or "return" based on current state.
   **************************************************************************/
  submitScanBtn.addEventListener('click', async ()=>{
    const user = auth.currentUser;
    if(!user){ showToast('Please sign in with Google first.'); return; }
    if(!lastRawResult){ showToast('No QR code scanned yet.'); return; }

    submitScanBtn.disabled = true;
    permissionStatus.textContent = 'Processing...';

    try{
      const forced = scanMode.value === 'auto' ? null : scanMode.value;
      const {type, id} = await resolveTypeAndId(lastRawResult, forced);
      if(type === 'unknown'){ throw new Error('Unknown QR. Use a valid Scooty/Battery code.'); }

      lastDeviceInfo.textContent = `${type.toUpperCase()}: ${id}`;

      // Load user to decide intent quickly (assign vs return)
      const uSnap = await db.collection('users').doc(user.email).get();
      const u = uSnap.data();

      if(type === 'scooty'){
        if(!u.linkedScooter){
          await assignScootyTx(user.email, id);
          showToast(`Scooty ${id} assigned.`);
        }else if(u.linkedScooter === id){
          await returnScootyTx(user.email, id);
          showToast(`Scooty ${id} returned.`);
        }else{
          throw new Error(`You already hold scooty ${u.linkedScooter}. Return it first.`);
        }
      } else if(type === 'battery'){
        if(!u.linkedBattery){
          await assignBatteryTx(user.email, id);
          showToast(`Battery ${id} assigned to your scooty.`);
        }else if(u.linkedBattery === id){
          await returnBatteryTx(user.email, id);
          showToast(`Battery ${id} returned.`);
        }else{
          throw new Error(`You already hold battery ${u.linkedBattery}. Return it first.`);
        }
      }

      await loadUserDevices();
      await loadLogs();
    }catch(e){
      console.error(e);
      showToast(e.message || 'Operation failed.');
    }finally{
      permissionStatus.textContent = 'Done';
      submitScanBtn.disabled = false;
    }
  });

  /**************************************************************************
   * ========================= UI: USER & LOGS ==============================
   **************************************************************************/
  async function loadUserDevices(){
    const user = auth.currentUser; if(!user) return;
    const uDoc = await db.collection('users').doc(user.email).get();
    const data = uDoc.exists ? uDoc.data() : null;
    linkedScooter.textContent = data && data.linkedScooter ? data.linkedScooter : '—';
    linkedBattery.textContent = data && data.linkedBattery ? data.linkedBattery : '—';
  }

  async function loadLogs(){
    logList.innerHTML = `<div class="muted">Loading logs...</div>`;
    const q = db.collection('logs').orderBy('ts','desc').limit(50);
    const snap = await q.get();
    logList.innerHTML = '';
    if(snap.empty){
      logList.innerHTML = '<div class="muted">No logs yet</div>';
      return;
    }
    snap.forEach(doc=>{
      const d = doc.data();
      const when = d.ts ? new Date(d.ts.toDate()).toLocaleString() : '—';
      const el = document.createElement('div');
      el.className = 'log-item';
      el.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center">
        <div><strong>${(d.action||'').toUpperCase()}</strong> &nbsp; ${d.deviceType} <span style="opacity:.9">(${d.deviceId})</span></div>
        <div class="muted" style="font-size:12px">${when}</div>
      </div>
      <div class="muted" style="margin-top:6px">user: ${escapeHtml(d.email||'')} • payload: <code>${escapeHtml(d.rawPayload||'')}</code></div>`;
      logList.appendChild(el);
    });
  }
  refreshLogs.addEventListener('click', loadLogs);

  function escapeHtml(s){ return (s+'').replace(/[&<>"]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }
  </script>
</body>
</html>
