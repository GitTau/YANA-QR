<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Yana QR - Rider Register</title>

  <style>
    :root{
      --bg:#0a0f12;
      --action:#00eaff;
      --muted:#9aa6ac;
      --glass: rgba(255,255,255,0.06);
      --radius:14px;
    }
    html,body{background:var(--bg);color:#eaf4f8;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,"Noto Sans",sans-serif;line-height:1.4;margin:0}
    *{box-sizing:border-box}
    .container{max-width:1100px;margin:28px auto;padding:24px}
    header{display:flex;align-items:center;gap:18px;margin-bottom:22px}
    .logo{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;width:100%}
    .brand{font-size:18px;font-weight:600}
    .sub{font-size:12px;color:var(--muted)}
    .top-actions{margin-left:auto;display:flex;gap:10px;align-items:center}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:18px;border-radius:var(--radius);box-shadow:0 6px 24px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.03)}
    .btn{background:var(--action);border:none;color:#001;padding:10px 16px;border-radius:12px;font-weight:700;cursor:pointer;box-shadow:0 6px 18px rgba(0,234,255,0.12)}
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:600}
    .small{font-size:13px;padding:8px 10px;border-radius:10px}
    .grid{display:grid;grid-template-columns:1fr 420px;gap:18px}
    @media(max-width:960px){ .grid{grid-template-columns:1fr} }
    .scanner{display:flex;flex-direction:column;gap:12px}
    #video{width:100%;border-radius:12px;background:#000;height:360px;object-fit:cover;border:1px solid rgba(255,255,255,0.03)}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    .status{padding:8px;border-radius:10px;background:var(--glass);color:var(--muted);font-size:13px}
    .info-row{display:flex;gap:10px;align-items:center;justify-content:space-between;margin-top:8px}
    .log-list{max-height:380px;overflow:auto;margin-top:8px;padding-right:8px}
    .log-item{padding:10px;border-radius:10px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);margin-bottom:8px;font-size:13px}
    .muted{color:var(--muted);font-size:13px}
    #registrationUI .form-input{width:100%;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.08);background:rgba(255,255,255,0.04);color:#fff;outline:none}
    #registrationUI label{display:block;margin-bottom:6px}
  </style>
</head>
<body>
  <div class="container">
    <header class="logo card">
      <div style="display:flex;gap:12px;align-items:center">
        <svg viewBox="0 0 24 24" width="28" height="28" aria-hidden="true">
          <rect x="2" y="2" width="20" height="20" rx="4" fill="#00eaff" />
          <path d="M7 12h10M12 7v10" stroke="#001f23" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        <div>
          <div class="brand">Yana — Rider QR</div>
          <div class="sub">Scan · Register · Log</div>
        </div>
      </div>
      <div class="top-actions">
        <div id="user-email" class="muted">Not signed in</div>
        <button id="signinBtn" class="btn small">Sign in with Google</button>
        <button id="signoutBtn" class="btn small ghost" style="display:none">Sign out</button>
      </div>
    </header>

    <!-- Registration -->
    <div id="registrationUI" class="card" style="display:none; margin-bottom:18px;">
      <div style="font-weight:700;margin-bottom:10px">Rider Registration</div>
      <div class="muted" style="margin-bottom:10px">Please complete your details. Admin will approve your access.</div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:8px">
        <div><div class="muted" style="font-size:12px">Name</div><div id="regName" style="font-weight:600">—</div></div>
        <div><div class="muted" style="font-size:12px">Email</div><div id="regEmail" style="font-weight:600">—</div></div>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px">
        <div>
          <label class="muted" style="font-size:12px">Phone Number</label>
          <input id="regPhone" class="form-input" type="text" placeholder="Enter phone number">
        </div>
        <div>
          <label class="muted" style="font-size:12px">Aadhar Number</label>
          <input id="regAadhar" class="form-input" type="text" placeholder="Enter Aadhar number">
        </div>
      </div>
      <div style="margin-top:12px;display:flex;gap:8px;align-items:center">
        <button id="submitRegistration" class="btn small">Submit Registration</button>
        <div class="muted" style="font-size:12px">Status: <span id="regStatus">Pending</span></div>
      </div>
    </div>

    <!-- App main (gated by approval) -->
    <div id="appMain" class="grid" style="display:none">
      <div class="card scanner">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">Start Scanning</div>
        </div>

        <video id="video" playsinline></video>

        <div class="controls">
          <button id="startCam" class="btn small">Start Camera</button>
          <button id="stopCam" class="btn small ghost" style="display:none">Stop Camera</button>
          <select id="scanMode" class="small" style="background:rgba(255,255,255,0.06);color:#fff;padding:8px;border-radius:10px">
            <option value="auto">Auto-detect</option>
            <option value="scooter">Scooter</option>
            <option value="battery">Battery</option>
          </select>
          <div class="status" id="permissionStatus">Camera idle</div>
        </div>

        <div class="status">Last decoded: <span id="lastDecoded">—</span></div>
        <div class="status">Parsed: <span id="lastDeviceInfo">—</span></div>

        <div style="display:flex;gap:8px;align-items:center">
          <button id="submitScan" class="btn">Submit</button>
          <div class="muted">Submits the detected scooter/battery based on the mode</div>
        </div>

        <div class="card" style="padding:12px">
          <div style="font-weight:700">Help</div>
          <div class="muted" style="font-size:13px">Codes like <code>YEV001</code> / <code>YBT001</code> or <code>scooter:YEV001</code> / <code>battery:YBT001</code> work best. Plain IDs are auto-detected.</div>
        </div>
      </div>

      <aside class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">Rider & Devices</div>
          <button id="refreshLogs" class="btn small ghost">Refresh</button>
        </div>
        <div style="margin-top:8px">
          <div class="info-row"><div class="muted">Rider</div><div id="riderInfo">—</div></div>
          <div class="info-row"><div class="muted">Linked scooter</div><div id="linkedScooter">—</div></div>
          <div class="info-row"><div class="muted">Linked battery</div><div id="linkedBattery">—</div></div>
        </div>
        <div class="log-list" id="logList"></div>
      </aside>
    </div>

    <footer class="muted">Built for Yana — keep your riders & devices tracked. Logs saved to Firestore.</footer>
  </div>

  <!-- SDKs -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
  <script src="https://unpkg.com/jsqr/dist/jsQR.js"></script>

  <script>
  const firebaseConfig = {
    apiKey: "AIzaSyCP7KKqJhtauDVonZ-6ApHRitu7CCdV0Ns",
    authDomain: "yana-qr.firebaseapp.com",
    projectId: "yana-qr",
    storageBucket: "yana-qr.firebasestorage.app",
    messagingSenderId: "905613005387",
    appId: "1:905613005387:web:b0d8464d826972654b73ce",
    measurementId: "G-9P9DLJGQHQ"
  };
  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.firestore();

  const video = document.getElementById('video');
  const startCamBtn = document.getElementById('startCam');
  const stopCamBtn = document.getElementById('stopCam');
  const permissionStatus = document.getElementById('permissionStatus');
  const lastDecoded = document.getElementById('lastDecoded');
  const lastDeviceInfo = document.getElementById('lastDeviceInfo');
  const submitScanBtn = document.getElementById('submitScan');
  const scanMode = document.getElementById('scanMode');
  const signinBtn = document.getElementById('signinBtn');
  const signoutBtn = document.getElementById('signoutBtn');
  const userEmailEl = document.getElementById('user-email');
  const riderInfo = document.getElementById('riderInfo');
  const linkedScooter = document.getElementById('linkedScooter');
  const linkedBattery = document.getElementById('linkedBattery');
  const logList = document.getElementById('logList');
  const refreshLogs = document.getElementById('refreshLogs');

  signinBtn.addEventListener('click', async () => {
    try{
      signinBtn.disabled = true;
      const provider = new firebase.auth.GoogleAuthProvider();
      await auth.signInWithPopup(provider);
    }catch(e){
      console.error('Sign-in failed', e);
      alert('Sign-in failed: '+e.message);
    } finally {
      signinBtn.disabled = false;
    }
  });

  signoutBtn.addEventListener('click', async ()=>{ await auth.signOut(); });

  auth.onAuthStateChanged(async (user)=>{
    if(user){
      userEmailEl.textContent = user.email;
      riderInfo.textContent = (user.displayName || 'Rider') + ' (' + user.email + ')';
      signinBtn.style.display = 'none';
      signoutBtn.style.display = 'inline-block';

      const uDocRef = db.collection('users').doc(user.email);

      // Ensure a base user doc exists
      await db.runTransaction(async (tx) => {
        const snap = await tx.get(uDocRef);
        if (!snap.exists) {
          tx.set(uDocRef, {
            email: user.email,
            name: user.displayName || "",
            phone: null,
            aadhar: null,
            status: "pending",
            linkedScooter: null,
            linkedBattery: null,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
          });
        }
      });

      // Attach registration submit handler (idempotent attach)
      attachRegistrationHandler();

      // Decide which UI to show
      checkUserStatus(user.email, user.displayName);
    } else {
      userEmailEl.textContent = 'Not signed in';
      riderInfo.textContent = '—';
      linkedScooter.textContent = '—';
      linkedBattery.textContent = '—';
      signinBtn.style.display = 'inline-block';
      signoutBtn.style.display = 'none';
      logList.innerHTML = '';
      document.getElementById('appMain').style.display = 'none';
      document.getElementById('registrationUI').style.display = 'none';
      stopCamera();
    }
  });

  async function checkUserStatus(email, displayName) {
    try{
      const userRef = db.collection('users').doc(email);
      const snap = await userRef.get();
      if(!snap.exists){
        document.getElementById('appMain').style.display = 'none';
        document.getElementById('registrationUI').style.display = 'none';
        return;
      }
      const data = snap.data() || {};
      if(data.status === 'approved'){
        document.getElementById('appMain').style.display = '';
        document.getElementById('registrationUI').style.display = 'none';
        loadUserDevices();
        loadLogs();
      } else if(data.status === 'pending' || !data.status){
        document.getElementById('appMain').style.display = 'none';
        document.getElementById('registrationUI').style.display = '';
        document.getElementById('regName').textContent = displayName || '';
        document.getElementById('regEmail').textContent = email || '';
        document.getElementById('regStatus').textContent = 'Pending';
      } else if(data.status === 'rejected'){
        document.getElementById('appMain').style.display = 'none';
        document.getElementById('registrationUI').style.display = 'none';
        alert('Your registration has been rejected. Please contact support.');
      } else {
        document.getElementById('appMain').style.display = 'none';
        document.getElementById('registrationUI').style.display = '';
      }
    }catch(e){
      console.error('Status check error', e);
    }
  }

  function attachRegistrationHandler(){
    const btn = document.getElementById('submitRegistration');
    if(!btn || btn.dataset.bound === "1") return;
    btn.dataset.bound = "1";
    btn.addEventListener('click', async ()=>{
      try{
        const u = auth.currentUser;
        if(!u){ alert('Please sign in first'); return; }
        const phone = (document.getElementById('regPhone').value||'').trim();
        const aadhar = (document.getElementById('regAadhar').value||'').trim();
        if(!phone || !aadhar){
          alert('Please enter phone and aadhar.');
          return;
        }
        btn.disabled = true;
        const userRef = db.collection('users').doc(u.email);
        const snap = await userRef.get();
        const payload = {
          phone, aadhar,
          status:'pending',
          submittedAt: firebase.firestore.FieldValue.serverTimestamp()
        };
        if(!snap.exists || !snap.data().createdAt){
          payload.createdAt = firebase.firestore.FieldValue.serverTimestamp();
        }
        await userRef.set(payload, { merge:true });
        document.getElementById('regStatus').textContent = 'Pending (submitted)';
        alert('Registration submitted. Wait for admin approval.');
      }catch(err){
        console.error('Registration submit error', err);
        alert('Failed to submit registration: ' + (err.message || 'Unknown error'));
      } finally {
        btn.disabled = false;
      }
    });
  }

  let stream = null;
  let scanning = false;
  let scanInterval = null;
  let lastRawResult = null;
  let lastParsedResult = { type: 'unknown', id: '', raw: '' };
  let lastUnknownIdLogged = null;

  async function startCamera(){
    try{
      permissionStatus.textContent = 'Requesting camera...';
      stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
      video.srcObject = stream;
      await video.play();
      permissionStatus.textContent = 'Camera active';
      startCamBtn.style.display = 'none';
      stopCamBtn.style.display = 'inline-block';
      scanning = true;
      scanLoop();
    }catch(err){
      console.error('Camera error', err);
      permissionStatus.textContent = 'Camera permission denied or not available';
      alert('Camera access is required for scanning. Please allow camera permissions and try again.');
    }
  }
  function stopCamera(){
    scanning = false;
    permissionStatus.textContent = 'Camera stopped';
    startCamBtn.style.display = 'inline-block';
    stopCamBtn.style.display = 'none';
    if(stream){ stream.getTracks().forEach(t=>t.stop()); stream = null; }
    if(scanInterval){ clearInterval(scanInterval); scanInterval = null; }
  }
  startCamBtn.addEventListener('click', startCamera);
  stopCamBtn.addEventListener('click', stopCamera);

  function scanLoop(){
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently:true });
    scanInterval = setInterval(async ()=>{
      if(!scanning || !video.videoWidth) return;
      canvas.width = video.videoWidth; canvas.height = video.videoHeight;
      ctx.drawImage(video,0,0,canvas.width,canvas.height);
      const imageData = ctx.getImageData(0,0,canvas.width,canvas.height);
      const code = jsQR(imageData.data, canvas.width, canvas.height);
      if(code && code.data && code.data !== lastRawResult){
        lastRawResult = code.data;
        lastDecoded.textContent = code.data;
        const parsed = await parsePayload(code.data);
        lastParsedResult = parsed;
        lastDeviceInfo.textContent = parsed.type + ' → ' + (parsed.id || '—');
        scanning = false;
        setTimeout(() => stopCamera(), 50);
      }
    }, 400);
  }

  async function parsePayload(raw){
    const rawTrim = (raw||'').trim();
    if(!rawTrim){ return { type:'unknown', id:'', raw:rawTrim }; }

    // Direct patterns: YEVxxx / YBTxxx
    let m = rawTrim.match(/^(YEV\\d+|YBT\\d+)$/i);
    if(m){
      const id = m[1].toUpperCase();
      const type = /^YEV/i.test(id) ? 'scooter' : 'battery';
      return { type, id, raw: rawTrim, source:'direct_pattern' };
    }

    // Legacy prefixes
    m = rawTrim.match(/^(scooter|battery)\\s*:\\s*([A-Za-z0-9_-]+)$/i);
    if(m){
      const id = m[2].toUpperCase();
      const type = m[1].toLowerCase();
      return { type, id, raw: rawTrim, source:'legacy_prefix' };
    }

    // Heuristic candidate
    const candidateId = rawTrim.toUpperCase().replace(/[^A-Z0-9:_-]/g, '');
    if(/^YEV\\d+/.test(candidateId) || /^SCOOT/.test(candidateId)){
      return { type:'scooter', id:candidateId, raw:rawTrim, source:'heuristic' };
    }
    if(/^YBT\\d+/.test(candidateId) || /^BAT\\d+/.test(candidateId) || /^BATTERY/.test(candidateId)){
      return { type:'battery', id:candidateId, raw:rawTrim, source:'heuristic' };
    }

    // Lookup against existing collections to infer type
    try{
      const [sSnap, bSnap] = await Promise.all([
        db.collection('scooties').doc(candidateId).get(),
        db.collection('batteries').doc(candidateId).get()
      ]);
      if(sSnap.exists){ return { type:'scooter', id:candidateId, raw:rawTrim, source:'collection_lookup' }; }
      if(bSnap.exists){ return { type:'battery', id:candidateId, raw:rawTrim, source:'collection_lookup' }; }
    }catch(e){
      console.warn('Lookup failed', e);
    }

    if(candidateId && lastUnknownIdLogged !== candidateId){
      lastUnknownIdLogged = candidateId;
      const u = auth.currentUser;
      logOutOfBand({
        email: u ? u.email : null,
        action: 'unknown_qr',
        deviceType: 'unknown',
        deviceId: candidateId,
        rawPayload: rawTrim
      });
      permissionStatus.textContent = 'Unknown QR: ' + candidateId;
    }

    return { type:'unknown', id:'', raw:rawTrim };
  }

  submitScanBtn.addEventListener('click', async ()=>{
    const mode = scanMode.value;
    if(lastParsedResult.type === 'unknown' || !lastParsedResult.id){
      alert('No valid scooter/battery detected yet.');
      return;
    }
    if(mode !== 'auto' && mode !== lastParsedResult.type){
      alert('Scan mode is "' + mode + '" but QR parsed as "' + lastParsedResult.type + '". Please fix mode or rescan.');
      return;
    }
    try{
      if(lastParsedResult.type === 'scooter'){
        await assignOrReturnScooter(lastParsedResult.id, lastParsedResult.raw);
      } else if(lastParsedResult.type === 'battery'){
        await assignOrReturnBattery(lastParsedResult.id, lastParsedResult.raw);
      }
    }catch(err){
      console.error(err);
      alert(err.message || 'Submit failed.');
    }
  });

  function userDocRef(email){ return db.collection('users').doc(email); }
  function scootyDocRef(scooterId){ return db.collection('scooties').doc(scooterId); }
  function batteryDocRef(batteryId){ return db.collection('batteries').doc(batteryId); }
  const logsRef = db.collection('logs');

  async function logOutOfBand(d){
    try{ await logsRef.add({ ts: firebase.firestore.FieldValue.serverTimestamp(), ...d }); }
    catch(e){ console.warn('logOutOfBand failed', e); }
  }

  async function loadUserDevices(){
    const u = auth.currentUser;
    if(!u) return;
    const snap = await userDocRef(u.email).get();
    const data = snap.exists ? snap.data() : {};
    riderInfo.textContent = (u.displayName || 'Rider') + ' (' + u.email + ')';
    linkedScooter.textContent = data.linkedScooter || '—';
    linkedBattery.textContent = data.linkedBattery || '—';
  }

  async function loadLogs(){
    logList.innerHTML = '';
    const q = await logsRef.orderBy('ts', 'desc').limit(25).get();
    q.forEach(doc=>{
      const d = doc.data() || {};
      const el = document.createElement('li');
      el.className = 'log-item';
      el.innerHTML = '<div style="font-weight:600">' + (d.action||'').replace(/_/g,' ') + '</div>' +
                     '<div class="muted">' + (d.deviceType||'-') + ' • ' + (d.deviceId||'-') + '</div>' +
                     '<div class="muted" style="margin-top:6px">user: ' + (d.email||'-') + '</div>';
      logList.appendChild(el);
    });
  }

  async function assignOrReturnScooter(scooterId, rawPayload){
    if(!scooterId) throw new Error('Invalid scooter id');
    const u = auth.currentUser;
    if(!u) throw new Error('Not signed in');

    await db.runTransaction(async (tx)=>{
      const email = u.email;
      const userRef = userDocRef(email);
      const scootyRef = scootyDocRef(scooterId);

      const [userSnap, scootySnap] = await Promise.all([tx.get(userRef), tx.get(scootyRef)]);
      if(!userSnap.exists){ throw new Error('User record missing'); }
      const user = userSnap.data() || {};

      if(scootySnap.exists){
        const s = scootySnap.data() || {};
        if(s.currentBatteryId && !s.currentRiderEmail){
          tx.set(scootyRef, { currentBatteryId:null, status:'free' }, { merge:true });
        }
      }

      let scooty;
      if(!scootySnap.exists){
        scooty = { scootyId: scooterId, currentBatteryId: null, currentRiderEmail: null, status: 'free' };
        tx.set(scootyRef, scooty);
      } else {
        scooty = scootySnap.data();
      }

      if(user.linkedScooter === scooterId){
        // ✅ Remove battery requirement and unlink only the scooter
      tx.set(userRef, { linkedScooter: null }, { merge: true });
      tx.set(scootyRef, { scootyId: scooterId, currentRiderEmail: null, currentBatteryId: null, status: 'free' }, { merge: true });

      // If a battery was mounted on the scooter, detach it from the scooter
      // but keep it assigned to the rider (battery remains "assigned").
      if (scooty.currentBatteryId) {
        const batteryRef = db.collection('batteries').doc(scooty.currentBatteryId);
        tx.set(batteryRef, {
          batteryId: scooty.currentBatteryId,
          assignedScootyId: null,
          // keep assignedRiderEmail as-is so battery remains linked to rider
          status: 'assigned'
        }, { merge: true });
        }
        tx.set(logsRef.doc(), { ts: firebase.firestore.FieldValue.serverTimestamp(), email, action: 'return_scooter', deviceType: 'scooter', deviceId: scooterId, rawPayload });
        return;
      }

      if(user.linkedScooter){
        throw new Error("You already have a scooter assigned.");
      }
      if(scooty.currentRiderEmail && scooty.currentRiderEmail !== email){
        throw new Error("This scooter is already assigned to another rider.");
      }

      tx.set(userRef, { linkedScooter: scooterId }, { merge:true });
      tx.set(scootyRef, { currentRiderEmail: email, status:'assigned' }, { merge:true });
      tx.set(logsRef.doc(), { ts: firebase.firestore.FieldValue.serverTimestamp(), email, action:'assign_scooter', deviceType:'scooter', deviceId:scooterId, rawPayload });
    });

    await loadUserDevices();
    await loadLogs();
  }

  async function assignOrReturnBattery(batteryId, rawPayload){
    if(!batteryId) throw new Error('Invalid battery id');
    const u = auth.currentUser;
    if(!u) throw new Error('Not signed in');

    await db.runTransaction(async (tx)=>{
      const email = u.email;
      const userRef = userDocRef(email);
      const userSnap = await tx.get(userRef);
      if(!userSnap.exists) throw new Error('User missing');
      const user = userSnap.data() || {};

      if(!user.linkedScooter){
        throw new Error("Assign a scooter first.");
      }

      const batteryRef = batteryDocRef(batteryId);
      const scootyRef = scootyDocRef(user.linkedScooter);

      const [batterySnap, scootySnap] = await Promise.all([tx.get(batteryRef), tx.get(scootyRef)]);
      let battery = batterySnap.exists ? (batterySnap.data()||{}) : { batteryId, assignedScootyId:null, assignedRiderEmail:null, status:'free' };
      let scooty = scootySnap.exists ? (scootySnap.data()||{}) : { scootyId:user.linkedScooter, currentBatteryId:null, currentRiderEmail:email, status:'assigned' };

      if(user.linkedBattery === batteryId){
        if(scooty.currentBatteryId !== batteryId){
          throw new Error("Invalid state: rider battery doesn't match scooter battery");
        }
        tx.set(userRef, { linkedBattery:null }, { merge:true });
        tx.set(scootyRef, { currentBatteryId:null, status:'assigned' }, { merge:true });
        tx.set(batteryRef, { assignedScootyId:null, assignedRiderEmail:null, status:'free' }, { merge:true });
        tx.set(logsRef.doc(), { ts:firebase.firestore.FieldValue.serverTimestamp(), email, action:'return_battery', deviceType:'battery', deviceId:batteryId, rawPayload });
        return;
      }

      if(user.linkedBattery && user.linkedBattery !== batteryId){
        throw new Error("Please return your current battery first.");
      }
      if(battery.assignedRiderEmail && battery.assignedRiderEmail !== email){
        throw new Error("This battery is already assigned to another rider.");
      }
      if(battery.assignedScootyId && battery.assignedScootyId !== user.linkedScooter){
        throw new Error("This battery is already assigned to another scooter.");
      }
      if(scooty.currentBatteryId && scooty.currentBatteryId !== batteryId){
        throw new Error("This scooter already has a different battery.");
      }

      tx.set(userRef, { linkedBattery:batteryId }, { merge:true });
      tx.set(batteryRef, { batteryId, assignedScootyId:user.linkedScooter, assignedRiderEmail:email, status:'assigned' }, { merge:true });
      tx.set(scootyRef, { currentBatteryId:batteryId, status:'assigned' }, { merge:true });
      tx.set(logsRef.doc(), { ts:firebase.firestore.FieldValue.serverTimestamp(), email, action:'assign_battery', deviceType:'battery', deviceId:batteryId, rawPayload });
    });

    await loadUserDevices();
    await loadLogs();
  }

  refreshLogs.addEventListener('click', loadLogs);
  window.addEventListener('beforeunload', ()=>{ if(stream) stream.getTracks().forEach(t=>t.stop()); });
  </script>
</body>
</html>
