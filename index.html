<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Yana QR - Rider Register</title>

  <!-- ========== STYLES ========== -->
  <style>
    /* ---------- Theme & layout ---------- */
    :root{
      --bg:#000;
      --action:#00eaff;
      --muted: #9aa6ac;
      --card:#0b0b0b;
      --glass: rgba(255,255,255,0.03);
      --accent-text: #001f23;
      --radius:14px;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:#fff;}
    *{box-sizing:border-box}
    .container{ max-width:1100px;margin:28px auto;padding:24px; }

    header{ display:flex;align-items:center;gap:18px;margin-bottom:22px; }
    .logo{ display:flex;align-items:center;justify-content:space-between;padding:12px 16px; }
    .brand{font-size:18px;font-weight:600}
    .sub{font-size:12px;color:var(--muted)}
    .top-actions{margin-left:auto;display:flex;gap:10px;align-items:center}

    /* card */
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding:18px;border-radius:var(--radius);box-shadow:0 6px 24px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.03);
    }

    /* sign in/out */
    .btn{
      background:var(--action);border:none;color:#001; padding:10px 16px;border-radius:12px;font-weight:700;cursor:pointer;
      box-shadow:0 6px 18px rgba(0,234,255,0.12);
    }
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:600}
    .small{font-size:13px;padding:8px 10px;border-radius:10px;}

    /* two-column layout */
    .grid{display:grid;grid-template-columns:1fr 420px;gap:18px}
    @media(max-width:960px){ .grid{grid-template-columns:1fr} .logo{margin-right:auto}}

    /* scanner area */
    .scanner{ display:flex;flex-direction:column;gap:12px; }
    #video{width:100%;border-radius:12px; background:#000; height:360px;object-fit:cover;border:1px solid rgba(255,255,255,0.03)}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    .status{padding:8px;border-radius:10px;background:var(--glass);color:var(--muted);font-size:13px}

    /* device info & logs */
    .info-row{display:flex;gap:10px;align-items:center;justify-content:space-between;margin-top:8px}
    .log-list{max-height:380px;overflow:auto;margin-top:8px;padding-right:8px}
    .log-item{padding:10px;border-radius:10px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.03);margin-bottom:8px;font-size:13px}
    .muted{color:var(--muted);font-size:13px}

    /* input & file */
    .file-input{display:flex;gap:8px;align-items:center}
    .logo-preview{width:56px;height:56px;border-radius:8px;background:transparent;display:flex;align-items:center;justify-content:center;overflow:hidden}
    input[type=file]{display:none}
    label.file-btn{padding:8px 10px;border-radius:10px;border:1px dashed rgba(255,255,255,0.06);cursor:pointer;font-size:13px;color:var(--muted)}

    footer{margin-top:18px;color:var(--muted);font-size:13px;text-align:center}
  </style>
</head>

<body>
  <div class="container">
    <!-- HEADER: logo, brand, signin, svg upload -->
    <header>
      <img src="logo.svg" alt="App Logo" class="app-logo">

      <div class="logo card" id="logo-container" title="Click to upload new SVG logo (below)">
        <!-- (kept minimal to avoid layout change) -->
      </div>

      <div>
        <div class="brand">Yana — Rider QR</div>
        <div class="sub">Scan · Register · Log</div>
      </div>

      <div class="top-actions">
        <div id="user-email" class="muted">Not signed in</div>
        <button id="signinBtn" class="btn small">Sign in with Google</button>
        <button id="signoutBtn" class="btn small ghost" style="display:none">Sign out</button>
      </div>
    </header>

    <div class="grid">
      <!-- LEFT: Scanner + controls -->
      <div class="card scanner">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">Start Scanning</div>
        </div>

        <!-- video preview -->
        <video id="video" playsinline></video>

        <!-- controls -->
        <div class="controls">
          <button id="startCam" class="btn small">Start Camera</button>
          <button id="stopCam" class="btn small ghost">Stop Camera</button>

          <select id="scanMode" class="small" style="background:transparent;border:1px solid rgba(255,255,255,0.06);color:#fff;padding:8px;border-radius:10px">
            <option value="auto">Auto-detect (scooter/battery)</option>
            <option value="scooter">Force: Scooter</option>
            <option value="battery">Force: Battery</option>
          </select>

          <div id="permissionStatus" class="status">Camera idle</div>
        </div>

        <!-- last scan + action -->
        <div class="info-row">
          <div>
            <div class="muted">Last decoded</div>
            <div id="lastDecoded" style="font-weight:700">—</div>
            <div class="muted" id="lastDeviceInfo">—</div>
          </div>
          <div style="text-align:right">
            <button id="submitScan" class="btn small" disabled>Submit</button>
            <div class="muted" style="margin-top:6px;font-size:12px">Scan → Submit</div>
          </div>
        </div>

        <div class="muted" style="margin-top:8px;font-size:13px">Tip: QR payloads like <code>scooter:SC001</code> or <code>battery:BAT100</code> work best. Plain IDs are auto-detected.</div>

      </div>

      <!-- RIGHT: summary, device status, logs, upload logo -->
      <aside class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">Rider & Devices</div>
        </div>

        <div style="margin-top:12px">
          <div class="muted">Signed-in rider</div>
          <div id="riderInfo" style="font-weight:700;margin-top:6px">—</div>

          <div style="margin-top:12px" class="muted">Linked scooter</div>
          <div id="linkedScooter" style="font-weight:700;margin-top:6px">—</div>

          <div style="margin-top:12px" class="muted">Linked battery</div>
          <div id="linkedBattery" style="font-weight:700;margin-top:6px">—</div>
        </div>

        <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03);margin:14px 0">

        <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
          <div style="font-weight:700">Recent logs</div>
          <button id="refreshLogs" class="btn small ghost">Refresh</button>
        </div>

        <div class="log-list" id="logList">
          <!-- dynamic logs -->
        </div>
      </aside>
    </div>

    <footer class="muted">Built for Yana — keep your riders & devices tracked. Logs saved to Firestore.</footer>
  </div>

  <!-- ========== SCRIPTS ========== -->
  <!-- Firebase JS SDKs (modular compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <!-- QR decoding library: jsQR (lightweight) -->
  <script src="https://unpkg.com/jsqr/dist/jsQR.js"></script>

  <script>
  /**************************************************************************
   * ========================= IMPORTANT CONFIG ============================
   * Replace the firebaseConfig below with what you provided (already done).
   * This page uses Firebase Authentication (Google popup) + Firestore.
   **************************************************************************/

  const firebaseConfig = {
    apiKey: "AIzaSyCP7KKqJhtauDVonZ-6ApHRitu7CCdV0Ns",
    authDomain: "yana-qr.firebaseapp.com",
    projectId: "yana-qr",
    storageBucket: "yana-qr.firebasestorage.app",
    messagingSenderId: "905613005387",
    appId: "1:905613005387:web:b0d8464d826972654b73ce",
    measurementId: "G-9P9DLJGQHQ"
  };

  // ========== Initialize Firebase ==========
  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.firestore();

  /**************************************************************************
   * ========================= UI ELEMENTS =================================
   **************************************************************************/
  const video = document.getElementById('video');
  const startCamBtn = document.getElementById('startCam');
  const stopCamBtn = document.getElementById('stopCam');
  const permissionStatus = document.getElementById('permissionStatus');
  const lastDecoded = document.getElementById('lastDecoded');
  const lastDeviceInfo = document.getElementById('lastDeviceInfo');
  const submitScanBtn = document.getElementById('submitScan');
  const scanMode = document.getElementById('scanMode');
  const signinBtn = document.getElementById('signinBtn');
  const signoutBtn = document.getElementById('signoutBtn');
  const userEmailEl = document.getElementById('user-email');
  const riderInfo = document.getElementById('riderInfo');
  const linkedScooter = document.getElementById('linkedScooter');
  const linkedBattery = document.getElementById('linkedBattery');
  const logList = document.getElementById('logList');
  const refreshLogs = document.getElementById('refreshLogs');

  /**************************************************************************
   * ========================= AUTHENTICATION ===============================
   * We use Firebase Google provider with a single-click popup sign-in.
   **************************************************************************/

  signinBtn.addEventListener('click', async () => {
    try{
      signinBtn.disabled = true;
      const provider = new firebase.auth.GoogleAuthProvider();
      await auth.signInWithPopup(provider);
      signinBtn.disabled = false;
    }catch(e){
      console.error('Sign-in failed', e);
      alert('Sign-in failed: '+e.message);
      signinBtn.disabled = false;
    }
  });

  signoutBtn.addEventListener('click', async ()=>{
    await auth.signOut();
  });

  // Auth state change listener (updates UI & loads rider doc)
  auth.onAuthStateChanged(async (user)=>{
    if(user){
      userEmailEl.textContent = user.email;
      riderInfo.textContent = `${user.displayName || 'Rider'} (${user.email})`;
      signinBtn.style.display = 'none';
      signoutBtn.style.display = 'inline-block';

      // === ensure rider doc exists (riders/{email}) ===
      const riderRef = db.collection('riders').doc(user.email.toLowerCase());
      const riderSnap = await riderRef.get();
      if(!riderSnap.exists()){
        await riderRef.set({
          email: user.email.toLowerCase(),
          name: user.displayName||null,
          status: 'active',
          currentScootyId: null,
          currentBatteryId: null,
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
      }
      // refresh rider's linked devices & logs
      loadUserDevices();
      loadLogs();
    } else {
      userEmailEl.textContent = 'Not signed in';
      riderInfo.textContent = '—';
      linkedScooter.textContent = '—';
      linkedBattery.textContent = '—';
      signinBtn.style.display = 'inline-block';
      signoutBtn.style.display = 'none';
      logList.innerHTML = '';
    }
  });

  /**************************************************************************
   * ========================= CAMERA & QR SCANNER ===========================
   * We'll use getUserMedia, draw frames to a hidden canvas, run jsQR on them.
   **************************************************************************/
  let stream = null;
  let scanning = false;
  let scanInterval = null;
  let lastRawResult = null;

  // helper: start camera
  async function startCamera(){
    try{
      permissionStatus.textContent = 'Requesting camera...';
      stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
      video.srcObject = stream;
      await video.play();
      permissionStatus.textContent = 'Camera active';
      startCamBtn.style.display = 'none';
      stopCamBtn.style.display = 'inline-block';
      scanning = true;
      scanLoop();
    }catch(err){
      console.error('Camera error', err);
      permissionStatus.textContent = 'Camera permission denied or not available';
      alert('Camera access is required for scanning. Please allow camera permissions and try again.');
    }
  }

  // helper: stop camera
  function stopCamera(){
    scanning = false;
    permissionStatus.textContent = 'Camera stopped';
    startCamBtn.style.display = 'inline-block';
    stopCamBtn.style.display = 'none';
    if(stream){
      stream.getTracks().forEach(t=>t.stop());
      stream = null;
    }
    if(scanInterval){ clearInterval(scanInterval); scanInterval = null; }
  }

  startCamBtn.addEventListener('click', startCamera);
  stopCamBtn.addEventListener('click', stopCamera);

  // main scan loop: create a canvas and run jsQR on image data every 300ms
  function scanLoop(){
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    scanInterval = setInterval(()=>{
      if(!scanning || video.readyState !== video.HAVE_ENOUGH_DATA) return;
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      ctx.drawImage(video,0,0,canvas.width,canvas.height);
      const imageData = ctx.getImageData(0,0,canvas.width,canvas.height);
      const code = jsQR(imageData.data, imageData.width, imageData.height, {inversionAttempts: "attemptBoth"});
      if(code){
        // got a QR result
        lastRawResult = code.data.trim();
        lastDecoded.textContent = lastRawResult;
        // show a short device info using quickParse (no Firestore call here for speed)
        const parsed = quickParse(lastRawResult);
        lastDeviceInfo.textContent = (parsed.type !== 'unknown')
          ? `${parsed.type.toUpperCase()}: ${parsed.id}`
          : `ID: ${parsed.id}`;
        submitScanBtn.disabled = false;
        // brief flash on permissionStatus
        permissionStatus.textContent = `Detected ${parsed.type !== 'unknown' ? parsed.type : 'id'} ${parsed.id}`;
      }
    }, 300);
  }

  /**************************************************************************
   * ========================= PARSING / RESOLUTION =========================
   * No devices.txt — type is inferred from payload or Firestore existence.
   **************************************************************************/
  function quickParse(raw) {
    if (!raw) return { type: 'unknown', id: '', raw };
    const clean = raw.trim().toUpperCase();
    const m = /^(\s*(SCOOTY|SCOOTER|BATTERY)\s*[:\-]?\s*)([A-Z0-9_\-]+)\s*$/.exec(clean);
    if (m) {
      const t = m[2].startsWith('BAT') ? 'battery' : 'scooty';
      return { type: t, id: m[3], raw };
    }
    return { type: 'unknown', id: clean, raw };
  }

  async function resolveTypeFromFirestore(idLike) {
    const id = idLike.trim().toUpperCase();
    const [sSnap, bSnap] = await Promise.all([
      db.collection('scooties').doc(id).get(),
      db.collection('batteries').doc(id).get()
    ]);
    if (sSnap.exists) return { type: 'scooty', id, raw: idLike };
    if (bSnap.exists) return { type: 'battery', id, raw: idLike };
    return { type: 'unknown', id, raw: idLike };
  }

  /**************************************************************************
   * ========================= BUSINESS OPERATIONS ==========================
   * Fully transactional. Enforces your rules 2.x, 3.x, 4.x client-side.
   **************************************************************************/
  function nowTs() { return firebase.firestore.FieldValue.serverTimestamp(); }
  function riderRefByEmail(email){ return db.collection('riders').doc(email.toLowerCase()); }
  function scootyRefById(id){ return db.collection('scooties').doc(id.toUpperCase()); }
  function batteryRefById(id){ return db.collection('batteries').doc(id.toUpperCase()); }

  async function loadUserDevices(){
    const user = auth.currentUser; if(!user) return;
    const rDoc = await db.collection('riders').doc(user.email.toLowerCase()).get();
    const data = rDoc.exists ? rDoc.data() : null;
    linkedScooter.textContent = data && data.currentScootyId ? data.currentScootyId : '—';
    linkedBattery.textContent = data && data.currentBatteryId ? data.currentBatteryId : '—';
  }

  // Logs (last 50)
  async function loadLogs(){
    logList.innerHTML = `<div class="muted">Loading logs...</div>`;
    const q = db.collection('logs').orderBy('ts','desc').limit(50);
    const snap = await q.get();
    logList.innerHTML = '';
    if(snap.empty){ logList.innerHTML = '<div class="muted">No logs yet</div>'; return; }
    snap.forEach(doc=>{
      const d = doc.data();
      const when = d.ts ? new Date(d.ts.toDate()).toLocaleString() : '—';
      const el = document.createElement('div');
      el.className = 'log-item';
      el.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center">
        <div><strong>${d.action.toUpperCase()}</strong> &nbsp; ${d.deviceType} <span style="opacity:.9">(${d.batteryId || d.scootyId || ''})</span></div>
        <div class="muted" style="font-size:12px">${when}</div>
      </div>
      <div class="muted" style="margin-top:6px">user: ${d.email} • payload: <code>${escapeHtml(d.rawPayload || '')}</code></div>`;
      logList.appendChild(el);
    });
  }
  refreshLogs.addEventListener('click', loadLogs);

  function escapeHtml(s){ return (s+'').replace(/[&<>"]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

  // === Core transactions ===
  async function assignScooty(email, scootyId, rawPayload){
    const rRef = riderRefByEmail(email);
    const sRef = scootyRefById(scootyId);

    await db.runTransaction(async tx => {
      const [rSnap, sSnap] = await Promise.all([tx.get(rRef), tx.get(sRef)]);
      if (!sSnap.exists) throw new Error(`Scooty ${scootyId} does not exist.`);
      const rider = rSnap.data();
      const scooty = sSnap.data();

      if (rider.currentScootyId) throw new Error(`You already hold scooty ${rider.currentScootyId}. Return it first.`);
      if (scooty.currentRiderEmail && scooty.currentRiderEmail.toLowerCase() !== email.toLowerCase()){
        throw new Error(`Scooty ${scootyId} is assigned to another rider.`);
      }

      tx.update(rRef, { currentScootyId: scootyId, updatedAt: nowTs() });
      tx.update(sRef, { currentRiderEmail: email.toLowerCase(), lastUpdated: nowTs(), status: 'in_use' });

      tx.set(db.collection('logs').doc(), {
        ts: nowTs(), email: email.toLowerCase(),
        action: 'assign_scooty', deviceType: 'scooty',
        scootyId, batteryId: null, rawPayload
      });
    });
  }

  async function returnScooty(email, scootyId, rawPayload){
    const rRef = riderRefByEmail(email);
    const sRef = scootyRefById(scootyId);

    await db.runTransaction(async tx => {
      const [rSnap, sSnap] = await Promise.all([tx.get(rRef), tx.get(sRef)]);
      if (!sSnap.exists) throw new Error(`Scooty ${scootyId} does not exist.`);
      const rider = rSnap.data();
      const scooty = sSnap.data();

      if (rider.currentScootyId !== scootyId) throw new Error(`You do not hold scooty ${scootyId}.`);
      if (!scooty.currentBatteryId) throw new Error(`Scooty return not allowed without a battery.`);

      // Clear rider from scooty
      tx.update(sRef, { currentRiderEmail: null, lastUpdated: nowTs(), status: 'available' });

      // Clear assigned rider on the battery (keep its scooty link)
      const bRef = batteryRefById(scooty.currentBatteryId);
      const bSnap = await tx.get(bRef);
      if (bSnap.exists) {
        const battery = bSnap.data();
        if (battery.assignedRiderEmail && battery.assignedRiderEmail.toLowerCase() === email.toLowerCase()){
          tx.update(bRef, { assignedRiderEmail: null, lastUpdated: nowTs(), status: 'available' });
        }
      }

      // Rider clears scooty
      tx.update(rRef, { currentScootyId: null, updatedAt: nowTs() });

      tx.set(db.collection('logs').doc(), {
        ts: nowTs(), email: email.toLowerCase(),
        action: 'return_scooty', deviceType: 'scooty',
        scootyId, batteryId: scooty.currentBatteryId || null, rawPayload
      });
    });
  }

  async function assignBattery(email, batteryId, rawPayload){
    const rRef = riderRefByEmail(email);
    const bRef = batteryRefById(batteryId);

    await db.runTransaction(async tx => {
      const [rSnap, bSnap] = await Promise.all([tx.get(rRef), tx.get(bRef)]);
      if (!bSnap.exists) throw new Error(`Battery ${batteryId} does not exist.`);
      const rider = rSnap.data();
      const battery = bSnap.data();

      if (!rider.currentScootyId) throw new Error(`Assign a scooty before assigning a battery.`);
      if (rider.currentBatteryId) throw new Error(`You already hold battery ${rider.currentBatteryId}. Please return it first.`);

      if (battery.assignedScootyId && battery.assignedScootyId !== rider.currentScootyId){
        throw new Error(`Please return your current battery (this one belongs to another scooty).`);
      }

      // Update battery
      tx.update(bRef, {
        assignedScootyId: rider.currentScootyId,
        assignedRiderEmail: email.toLowerCase(),
        lastUpdated: nowTs(),
        status: 'in_use'
      });

      // Update scooty.currentBatteryId
      const sRef = scootyRefById(rider.currentScootyId);
      tx.update(sRef, { currentBatteryId: batteryId, lastUpdated: nowTs() });

      // Update rider
      tx.update(rRef, { currentBatteryId: batteryId, updatedAt: nowTs() });

      tx.set(db.collection('logs').doc(), {
        ts: nowTs(), email: email.toLowerCase(),
        action: 'assign_battery', deviceType: 'battery',
        scootyId: rider.currentScootyId, batteryId, rawPayload
      });
    });
  }

  async function returnBattery(email, batteryId, rawPayload){
    const rRef = riderRefByEmail(email);
    const bRef = batteryRefById(batteryId);

    await db.runTransaction(async tx => {
      const [rSnap, bSnap] = await Promise.all([tx.get(rRef), tx.get(bRef)]);
      if (!bSnap.exists) throw new Error(`Battery ${batteryId} does not exist.`);
      const rider = rSnap.data();
      const battery = bSnap.data();

      if (!rider.currentScootyId) throw new Error(`You don’t hold a scooty.`);
      if (rider.currentBatteryId !== batteryId){
        throw new Error(`Scan the battery currently linked to your scooty (${rider.currentBatteryId || 'none'}).`);
      }
      if (battery.assignedScootyId && battery.assignedScootyId !== rider.currentScootyId){
        throw new Error(`This battery belongs to another scooty.`);
      }

      // Clear battery links
      tx.update(bRef, { assignedScootyId: null, assignedRiderEmail: null, lastUpdated: nowTs(), status: 'available' });

      // Clear scooty.currentBatteryId but keep rider
      const sRef = scootyRefById(rider.currentScootyId);
      tx.update(sRef, { currentBatteryId: null, lastUpdated: nowTs() });

      // Update rider
      tx.update(rRef, { currentBatteryId: null, updatedAt: nowTs() });

      tx.set(db.collection('logs').doc(), {
        ts: nowTs(), email: email.toLowerCase(),
        action: 'return_battery', deviceType: 'battery',
        scootyId: rider.currentScootyId, batteryId, rawPayload
      });
    });
  }

  /**************************************************************************
   * ========================= SUBMIT / ROUTER ===============================
   * Scan result is routed to assign/return per current state.
   **************************************************************************/
  submitScanBtn.addEventListener('click', async ()=>{
    const user = auth.currentUser;
    if(!user){ alert('Please sign in with Google first.'); return; }
    if(!lastRawResult){ alert('No QR code scanned yet.'); return; }

    try{
      submitScanBtn.disabled = true;
      permissionStatus.textContent = 'Processing...';

      // Determine type
      let parsed = quickParse(lastRawResult);
      if (scanMode.value === 'scooter' || scanMode.value === 'scooty') parsed.type = 'scooty';
      if (scanMode.value === 'battery') parsed.type = 'battery';
      if (parsed.type === 'unknown') parsed = await resolveTypeFromFirestore(parsed.id);

      if (parsed.type === 'unknown') {
        throw new Error('Unknown device. Make sure the ID exists in Firestore (scooties/batteries).');
      }

      // Route
      const riderSnap = await db.collection('riders').doc(user.email.toLowerCase()).get();
      const rider = riderSnap.data();

      if (parsed.type === 'scooty') {
        if (!rider.currentScootyId) {
          await assignScooty(user.email, parsed.id, parsed.raw);
        } else if (rider.currentScootyId === parsed.id) {
          await returnScooty(user.email, parsed.id, parsed.raw);
        } else {
          throw new Error(`You already hold scooty ${rider.currentScootyId}. Return it first.`);
        }
      }

      if (parsed.type === 'battery') {
        if (!rider.currentBatteryId) {
          await assignBattery(user.email, parsed.id, parsed.raw);
        } else if (rider.currentBatteryId === parsed.id) {
          await returnBattery(user.email, parsed.id, parsed.raw);
        } else {
          throw new Error(`Please return your current battery (${rider.currentBatteryId}) before taking another.`);
        }
      }

      // UI refresh
      await loadUserDevices();
      await loadLogs();
      permissionStatus.textContent = 'Done';
    } catch (e){
      console.error(e);
      permissionStatus.textContent = 'Error';
      alert(e.message);
    } finally {
      submitScanBtn.disabled = false;
    }
  });

  /**************************************************************************
   * ========================= UTIL: Page unload cleanup ====================
   **************************************************************************/
  window.addEventListener('beforeunload', ()=>{
    if(stream) stream.getTracks().forEach(t=>t.stop());
  });

  </script>
</body>
</html>
