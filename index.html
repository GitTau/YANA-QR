<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Yana QR - Rider Register</title>

  <!-- ========== STYLES ========== -->
  <style>
    /* ---------- Theme & layout ---------- */
    :root{
      --bg:#000;
      --action:#00eaff;
      --muted: #9aa6ac;
      --card:#0b0b0b;
      --glass: rgba(255,255,255,0.03);
      --accent-text: #001f23;
      --radius:14px;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:#fff;}
    *{box-sizing:border-box}
    .container{
      max-width:1100px;margin:28px auto;padding:24px;
    }

    header{
      display:flex;align-items:center;gap:18px;margin-bottom:22px;
    }
    .logo{
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
    }
    .brand{font-size:18px;font-weight:600}
    .sub{font-size:12px;color:var(--muted)}
    .top-actions{margin-left:auto;display:flex;gap:10px;align-items:center}

    /* card */
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding:18px;border-radius:var(--radius);box-shadow:0 6px 24px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.03);
    }

    /* sign in/out */
    .btn{
      background:var(--action);border:none;color:#001; padding:10px 16px;border-radius:12px;font-weight:700;cursor:pointer;
      box-shadow:0 6px 18px rgba(0,234,255,0.12);
    }
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:600}
    .small{font-size:13px;padding:8px 10px;border-radius:10px;}

    /* two-column layout */
    .grid{display:grid;grid-template-columns:1fr 420px;gap:18px}
    @media(max-width:960px){ .grid{grid-template-columns:1fr} .logo{margin-right:auto}}

    /* scanner area */
    .scanner{
      display:flex;flex-direction:column;gap:12px;
    }
    #video{width:100%;border-radius:12px; background:#000; height:360px;object-fit:cover;border:1px solid rgba(255,255,255,0.03)}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    .status{padding:8px;border-radius:10px;background:var(--glass);color:var(--muted);font-size:13px}
    

     <video id="video" playsinline style="width:100%; max-width:400px; border:2px solid #00eaff; border-radius:12px;"></video>
     <p id="permissionStatus" style="color:white; text-align:center; margin-top:8px;">Camera idle</p>
     <p id="lastDecoded" style="color:#00eaff; text-align:center;"></p>
     <p id="lastDeviceInfo" style="color:#fff; text-align:center;"></p>
     <button id="startCamBtn" class="action-btn">Start Scanner</button>
     <button id="stopCamBtn" class="action-btn" style="display:none;">Stop Scanner</button>
     <button id="submitScanBtn" class="action-btn" disabled>Submit Scan</button>



    /* device info & logs */
    .info-row{display:flex;gap:10px;align-items:center;justify-content:space-between;margin-top:8px}
    .log-list{max-height:380px;overflow:auto;margin-top:8px;padding-right:8px}
    .log-item{padding:10px;border-radius:10px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.03);margin-bottom:8px;font-size:13px}
    .muted{color:var(--muted);font-size:13px}

    /* input & file */
    .file-input{display:flex;gap:8px;align-items:center}
    .logo-preview{width:56px;height:56px;border-radius:8px;background:transparent;display:flex;align-items:center;justify-content:center;overflow:hidden}
    input[type=file]{display:none}
    label.file-btn{padding:8px 10px;border-radius:10px;border:1px dashed rgba(255,255,255,0.06);cursor:pointer;font-size:13px;color:var(--muted)}

    footer{margin-top:18px;color:var(--muted);font-size:13px;text-align:center}
  </style>
</head>

<body>
  <div class="container">
    <!-- HEADER: logo, brand, signin, svg upload -->
    <header>
    <img src="logo.svg" alt="App Logo" class="app-logo">

      <div class="logo card" id="logo-container" title="Click to upload new SVG logo (below)">
          <rect x="2" y="2" width="20" height="20" rx="4" fill="#00eaff" />
          <path d="M7 12h10M12 7v10" stroke="#001f23" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </div>

      <div>
        <div class="brand">Yana — Rider QR</div>
        <div class="sub">Scan · Register · Log</div>
      </div>

      <div class="top-actions">
        <div id="user-email" class="muted">Not signed in</div>
        <button id="signinBtn" class="btn small">Sign in with Google</button>
        <button id="signoutBtn" class="btn small ghost" style="display:none">Sign out</button>
      </div>
    </header>

    <div class="grid">
      <!-- LEFT: Scanner + controls -->
      <div class="card scanner">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">Start Scanning</div>
        </div>

        <!-- video preview -->
        <video id="video" playsinline></video>

        <!-- controls -->
        <div class="controls">
          <button id="startCam" class="btn small">Start Camera</button>
          <button id="stopCam" class="btn small ghost">Stop Camera</button>

          <select id="scanMode" class="small" style="background:transparent;border:1px solid rgba(255,255,255,0.06);color:#fff;padding:8px;border-radius:10px">
            <option value="auto">Auto-detect (scooter/battery)</option>
            <option value="scooter">Force: Scooter</option>
            <option value="battery">Force: Battery</option>
          </select>

          <div id="permissionStatus" class="status">Camera idle</div>
        </div>

        <!-- last scan + action -->
        <div class="info-row">
          <div>
            <div class="muted">Last decoded</div>
            <div id="lastDecoded" style="font-weight:700">—</div>
            <div class="muted" id="lastDeviceInfo">—</div>
          </div>
          <div style="text-align:right">
            <button id="submitScan" class="btn small" disabled>Submit</button>
            <div class="muted" style="margin-top:6px;font-size:12px">Scan → Submit</div>
          </div>
        </div>

        <div class="muted" style="margin-top:8px;font-size:13px">Tip: QR payloads like <code>scooter:SC001</code> or <code>battery:BAT100</code> work best. Plain IDs are auto-detected.</div>

      </div>

      <!-- RIGHT: summary, device status, logs, upload logo -->
      <aside class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">Rider & Devices</div>
        </div>

        <div style="margin-top:12px">
          <div class="muted">Signed-in rider</div>
          <div id="riderInfo" style="font-weight:700;margin-top:6px">—</div>

          <div style="margin-top:12px" class="muted">Linked scooter</div>
          <div id="linkedScooter" style="font-weight:700;margin-top:6px">—</div>

          <div style="margin-top:12px" class="muted">Linked battery</div>
          <div id="linkedBattery" style="font-weight:700;margin-top:6px">—</div>
        </div>

        <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03);margin:14px 0">

        <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
          <div style="font-weight:700">Recent logs</div>
          <button id="refreshLogs" class="btn small ghost">Refresh</button>
        </div>

        <div class="log-list" id="logList">
          <!-- dynamic logs -->
        </div>
      </aside>
    </div>

    <footer class="muted">Built for Yana — keep your riders & devices tracked. Logs saved to Firestore.</footer>
  </div>

  <!-- ========== SCRIPTS ========== -->
  <!-- Firebase JS SDKs (modular) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <!-- QR decoding library: jsQR (lightweight) -->
  <script src="https://unpkg.com/jsqr/dist/jsQR.js"></script>

  <script>
  /**************************************************************************
   * ========================= IMPORTANT CONFIG ============================
   * Replace the firebaseConfig below with what you provided (already done).
   * This page uses Firebase Authentication (Google popup) + Firestore.
   **************************************************************************/

  const firebaseConfig = {
    apiKey: "AIzaSyCP7KKqJhtauDVonZ-6ApHRitu7CCdV0Ns",
    authDomain: "yana-qr.firebaseapp.com",
    projectId: "yana-qr",
    storageBucket: "yana-qr.firebasestorage.app",
    messagingSenderId: "905613005387",
    appId: "1:905613005387:web:b0d8464d826972654b73ce",
    measurementId: "G-9P9DLJGQHQ"
  };

  // ========== Initialize Firebase ==========
  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.firestore();

  /**************************************************************************
   * ========================= UI ELEMENTS =================================
   **************************************************************************/
  const video = document.getElementById('video');
  const startCamBtn = document.getElementById('startCam');
  const stopCamBtn = document.getElementById('stopCam');
  const permissionStatus = document.getElementById('permissionStatus');
  const lastDecoded = document.getElementById('lastDecoded');
  const lastDeviceInfo = document.getElementById('lastDeviceInfo');
  const submitScanBtn = document.getElementById('submitScan');
  const scanMode = document.getElementById('scanMode');
  const signinBtn = document.getElementById('signinBtn');
  const signoutBtn = document.getElementById('signoutBtn');
  const userEmailEl = document.getElementById('user-email');
  const riderInfo = document.getElementById('riderInfo');
  const linkedScooter = document.getElementById('linkedScooter');
  const linkedBattery = document.getElementById('linkedBattery');
  const logList = document.getElementById('logList');
  const refreshLogs = document.getElementById('refreshLogs');

  // === NEW: handy alias for server timestamps (safe to reuse)
  const serverTS = firebase.firestore.FieldValue.serverTimestamp();

  /**************************************************************************
   * ========================= AUTHENTICATION ===============================
   * We use Firebase Google provider with a single-click popup sign-in.
   * If you want Google One-Tap later, you'll need an OAuth client ID
   * from Google Cloud and small integration changes.
   **************************************************************************/

  signinBtn.addEventListener('click', async () => {
    try{
      signinBtn.disabled = true;
      const provider = new firebase.auth.GoogleAuthProvider();
      await auth.signInWithPopup(provider);
      signinBtn.disabled = false;
    }catch(e){
      console.error('Sign-in failed', e);
      alert('Sign-in failed: '+e.message);
      signinBtn.disabled = false;
    }
  });

  signoutBtn.addEventListener('click', async ()=>{
    await auth.signOut();
  });

  // Auth state change listener (updates UI & loads user doc)
  auth.onAuthStateChanged(async (user)=>{
    if(user){
      userEmailEl.textContent = user.email;
      riderInfo.textContent = `${user.displayName || 'Rider'} (${user.email})`;
      signinBtn.style.display = 'none';
      signoutBtn.style.display = 'inline-block';

      // ==== EXISTING (kept): ensure legacy `users/{email}` doc exists for UI compatibility
      const uDocRef = db.collection('users').doc(user.email);
      const uDoc = await uDocRef.get();
      if(!uDoc.exists){
        await uDocRef.set({
          email: user.email,
          name: user.displayName||null,
          createdAt: serverTS,
          linkedScooter: null,
          linkedBattery: null
        });
      }

      // === NEW: ensure new master Rider doc exists in `riders/{email}`
      const rDocRef = db.collection('riders').doc(user.email);
      const rDoc = await rDocRef.get();
      if(!rDoc.exists){
        await rDocRef.set({
          email: user.email,
          name: user.displayName||null,
          createdAt: serverTS,
          updatedAt: serverTS,
          currentScootyId: null,
          currentBatteryId: null
        });
      }

      // refresh user's linked devices (now reads from `riders` with fallback to `users`)
      loadUserDevices();
      // refresh some recent logs
      loadLogs();
    } else {
      userEmailEl.textContent = 'Not signed in';
      riderInfo.textContent = '—';
      linkedScooter.textContent = '—';
      linkedBattery.textContent = '—';
      signinBtn.style.display = 'inline-block';
      signoutBtn.style.display = 'none';
      logList.innerHTML = '';
    }
  });

  /**************************************************************************
   * ========================= CAMERA & QR SCANNER ===========================
   * We'll use getUserMedia, draw frames to a hidden canvas, run jsQR on them.
   **************************************************************************/
  let stream = null;
  let scanning = false;
  let scanInterval = null;
  let lastRawResult = null;

  // helper: start camera
  async function startCamera(){
    try{
      permissionStatus.textContent = 'Requesting camera...';
      stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
      video.srcObject = stream;
      await video.play();
      permissionStatus.textContent = 'Camera active';
      startCamBtn.style.display = 'none';
      stopCamBtn.style.display = 'inline-block';
      scanning = true;
      scanLoop();
    }catch(err){
      console.error('Camera error', err);
      permissionStatus.textContent = 'Camera permission denied or not available';
      alert('Camera access is required for scanning. Please allow camera permissions and try again.');
    }
  }

  // helper: stop camera
  function stopCamera(){
    scanning = false;
    permissionStatus.textContent = 'Camera stopped';
    startCamBtn.style.display = 'inline-block';
    stopCamBtn.style.display = 'none';
    if(stream){
      stream.getTracks().forEach(t=>t.stop());
      stream = null;
    }
    if(scanInterval){ clearInterval(scanInterval); scanInterval = null; }
  }

  startCamBtn.addEventListener('click', startCamera);
  stopCamBtn.addEventListener('click', stopCamera);

  // main scan loop: create a canvas and run jsQR on image data every 300ms
  function scanLoop(){
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    scanInterval = setInterval(()=>{
      if(!scanning || video.readyState !== video.HAVE_ENOUGH_DATA) return;
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      ctx.drawImage(video,0,0,canvas.width,canvas.height);
      const imageData = ctx.getImageData(0,0,canvas.width,canvas.height);
      const code = jsQR(imageData.data, imageData.width, imageData.height, {inversionAttempts: "attemptBoth"});
      if(code){
        // got a QR result
        lastRawResult = code.data.trim();
        // === UPDATED: parse understands prefixes (scooter:/battery:) and devices.txt fallback
        const parsed = parsePayload(lastRawResult);
        lastDecoded.textContent = parsed.raw;
        lastDeviceInfo.textContent = `${parsed.type.toUpperCase()}: ${parsed.id || '—'}`;
        submitScanBtn.disabled = !!parsed.id; // enable when we have an ID
        // brief flash on permissionStatus
        permissionStatus.textContent = parsed.id ? `Detected ${parsed.type} ${parsed.id}` : `Scan detected; choose type`;
      }
    }, 300);
  }

  /**************************************************************************
   * ========================= PARSING LOGIC =================================*/
let validDevices = { scooter: [], battery: [] };

// Load devices.txt once (from GitHub Pages or Firebase hosting)
async function loadValidDevices() {
  try {
    const res = await fetch("devices.txt"); // hosted alongside index.html
    const text = await res.text();
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);

    const newDevices = { scooter: [], battery: [] };
    for (const line of lines) {
      const [type, id] = line.split(':').map(x => x.trim().toUpperCase());
      if (type === "SCOOTER") newDevices.scooter.push(id);
      if (type === "BATTERY") newDevices.battery.push(id);
    }

    validDevices = newDevices;
    console.log("✅ Devices loaded:", validDevices);

  } catch (err) {
    console.error("❌ Could not load devices.txt", err);
  }
}

// Call at page load
loadValidDevices();

// === UPDATED: Parse scanned payload with support for "scooter:ID" / "battery:ID" prefixes.
// If type is unknown, we still return the cleaned ID so a forced mode can be applied.
function parsePayload(raw) {
  if (!raw) return { type: 'unknown', id: '', raw };

  const clean = String(raw).trim();
  const upper = clean.toUpperCase();

  // 1) Prefix patterns (most reliable)
  const scootyMatch = upper.match(/^SCOOTER[:\-\s]+([A-Z0-9\-\_]+)$/);
  if (scootyMatch) return { type: 'scooter', id: scootyMatch[1], raw: clean };

  const batteryMatch = upper.match(/^BATTERY[:\-\s]+([A-Z0-9\-\_]+)$/);
  if (batteryMatch) return { type: 'battery', id: batteryMatch[1], raw: clean };

  // 2) devices.txt allow-list (optional helper, not authoritative)
  if (validDevices.scooter.includes(upper)) {
    return { type: 'scooter', id: upper, raw: clean };
  }
  if (validDevices.battery.includes(upper)) {
    return { type: 'battery', id: upper, raw: clean };
  }

  // 3) Unknown type, but return the cleaned ID so user can force the mode
  return { type: 'unknown', id: upper, raw: clean };
}

  /**************************************************************************
   * ========================= SUBMIT / REGISTER LOGIC =======================
   * This now implements your master-list rules using:
   *  - riders/{email}
   *  - scooties/{ScootyID}
   *  - batteries/{BatteryID}
   * and keeps legacy users/{email} in sync for the existing UI.
   **************************************************************************/
  submitScanBtn.addEventListener('click', async ()=>{
    const user = auth.currentUser;
    if(!user){
      alert('Please sign in with Google first.');
      return;
    }
    if(!lastRawResult){
      alert('No QR code scanned yet. Please scan and then submit.');
      return;
    }

    // Parse the last scan
    let parsed = parsePayload(lastRawResult);

    // === NEW: if type is unknown, honor the dropdown (forced mode)
    if(parsed.type === 'unknown'){
      const forced = scanMode.value;
      if(forced === 'scooter' || forced === 'battery'){
        parsed = { type: forced, id: parsed.id, raw: parsed.raw };
        if(!parsed.id){
          alert('Could not detect an ID from the QR. Please scan again.');
          return;
        }
      } else {
        alert('Unable to detect device type. Select "Force: Scooter" or "Force: Battery" and submit again.');
        return;
      }
    }

    // perform transactional checks & updates
    try{
      submitScanBtn.disabled = true;
      permissionStatus.textContent = 'Processing...';
      await processScan(user.email, parsed.type, parsed.id, parsed.raw);
      permissionStatus.textContent = 'Done';
      // update UI
      loadUserDevices();
      loadLogs();
      submitScanBtn.disabled = false;
    }catch(e){
      submitScanBtn.disabled = false;
      permissionStatus.textContent = 'Error';
      alert('Operation failed: ' + e.message);
      console.error(e);
    }
  });

  /**
   * === NEW: Firestore helpers (typed collection refs)
   * These keep code readable and consistent.
   */
  function riderRef(email){ return db.collection('riders').doc(email); }
  function legacyUserRef(email){ return db.collection('users').doc(email); } // for UI mirroring only
  function scootyRef(id){ return db.collection('scooties').doc(id); }
  function batteryRef(id){ return db.collection('batteries').doc(id); }

  /**
   * === NEW: processScan implements the 4 flows with your rules:
   *  - Scooty Assignment
   *  - Scooty Return
   *  - Battery Assignment
   *  - Battery Return
   *
   * Decision:
   *  - Scanning a SCOOTER will ASSIGN if rider has none; otherwise RETURN if it’s the same scooty.
   *  - Scanning a BATTERY will ASSIGN if rider has none; otherwise RETURN if it’s the same battery.
   *  - All invariants are enforced inside one transaction.
   */
  async function processScan(email, deviceType, deviceId, rawPayload){
    const rRef = riderRef(email);
    const uRef = legacyUserRef(email); // keep legacy UI mirrored (linkedScooter/linkedBattery)
    const logsRef = db.collection('logs');

    await db.runTransaction(async (tx)=>{
      // --- Load rider master
      const riderSnap = await tx.get(rRef);
      if(!riderSnap.exists) throw new Error('Rider profile missing. Please sign out and sign in again.');
      const rider = riderSnap.data() || {};
      const currentScootyId = rider.currentScootyId || null;
      const currentBatteryId = rider.currentBatteryId || null;

      // Helper for logs
      const log = (action, extra={}) => {
        tx.set(logsRef.doc(), {
          ts: serverTS,
          email,
          action,
          deviceType,
          deviceId,
          rawPayload,
          ...extra
        });
      };

      // ============= SCOOTER BRANCH =============
      if(deviceType === 'scooter'){
        const sRef = scootyRef(deviceId);
        let sSnap = await tx.get(sRef);
        let scooty = sSnap.exists ? sSnap.data() : null;

        // If scooty doc doesn't exist, create it as available (safe default)
        if(!scooty){
          scooty = {
            scootyId: deviceId,
            currentBatteryId: null,
            currentRiderEmail: null,
            status: 'available',
            lastUpdated: serverTS
          };
          tx.set(sRef, scooty);
        }

        // CASE A: Assign scooty (rider has none)
        if(!currentScootyId){
          // Preconditions:
          if(scooty.currentRiderEmail && scooty.currentRiderEmail !== email){
            throw new Error(`Scooty ${deviceId} is already assigned to another rider (${scooty.currentRiderEmail}).`);
          }

          // Process:
          tx.update(rRef, { currentScootyId: deviceId, updatedAt: serverTS });
          // Mirror legacy users collection for existing UI
          tx.set(uRef, { linkedScooter: deviceId, updatedAt: serverTS }, { merge: true });

          // Retain existing battery on the scooty (if any); also ensure master consistency
          if(scooty.currentBatteryId){
            const bRef = batteryRef(scooty.currentBatteryId);
            const bSnap = await tx.get(bRef);
            if(!bSnap.exists){
              // Create missing battery doc to keep data consistent.
              tx.set(bRef, {
                batteryId: scooty.currentBatteryId,
                assignedScootyId: deviceId,
                assignedRiderEmail: null, // not auto-assign to rider on scooty assignment
                status: 'available',
                lastUpdated: serverTS
              });
            } else {
              const b = bSnap.data() || {};
              if(b.assignedScootyId && b.assignedScootyId !== deviceId){
                // Fix inconsistency in the same transaction
                tx.update(bRef, { assignedScootyId: deviceId, lastUpdated: serverTS });
              }
            }
          }

          // Update scooty status/rider link
          tx.update(sRef, { currentRiderEmail: email, status: 'in_use', lastUpdated: serverTS });

          log('assign_scooty');
          return;
        }

        // CASE B: Return scooty (toggle) if it's the same one
        if(currentScootyId === deviceId){
          // Preconditions: Scooty must have a battery linked
          if(!scooty.currentBatteryId){
            throw new Error('Scooty return is not allowed without a linked battery. Please link/scan its battery first.');
          }
          const bRef = batteryRef(scooty.currentBatteryId);
          const bSnap = await tx.get(bRef);
          const b = bSnap.exists ? (bSnap.data()||{}) : null;

          // Process:
          //  - Scooty: clear currentRiderEmail, keep currentBatteryId
          tx.update(sRef, { currentRiderEmail: null, status: 'available', lastUpdated: serverTS });

          //  - Battery: clear assignedRiderEmail, keep assignedScootyId
          if(bSnap.exists){
            tx.update(bRef, { assignedRiderEmail: null, lastUpdated: serverTS });
          }

          //  - Rider: clear currentScootyId, keep currentBatteryId
          tx.update(rRef, { currentScootyId: null, updatedAt: serverTS });
          // Mirror legacy UI
          tx.set(uRef, { linkedScooter: null, updatedAt: serverTS }, { merge: true });

          log('return_scooty', { batteryId: scooty.currentBatteryId || null });
          return;
        }

        // CASE C: Rider already has a different scooty
        throw new Error(`You already have a linked scooty (${currentScootyId}). Please return it first by scanning that scooty.`);

      } // end scooter branch

      // ============= BATTERY BRANCH =============
      if(deviceType === 'battery'){
        const bRef = batteryRef(deviceId);
        let bSnap = await tx.get(bRef);
        let battery = bSnap.exists ? bSnap.data() : null;

        // Create battery doc if missing (safe default)
        if(!battery){
          battery = {
            batteryId: deviceId,
            assignedScootyId: null,
            assignedRiderEmail: null,
            status: 'available',
            lastUpdated: serverTS
          };
          tx.set(bRef, battery);
        }

        // Rider must have a scooty before taking a battery
        if(!currentScootyId){
          throw new Error('Please assign a scooty first before linking a battery.');
        }

        // CASE A: Assign battery (rider has none)
        if(!currentBatteryId){
          // Preconditions:
          if(battery.assignedScootyId && battery.assignedScootyId !== currentScootyId){
            // Battery is linked to a different scooty → block per rule 3.2.1.2.2
            throw new Error('Please return your current battery. This battery is linked to another scooty.');
          }

          // Process:
          //  - Battery: link to rider’s scooty and rider
          tx.update(bRef, {
            assignedScootyId: currentScootyId,
            assignedRiderEmail: email,
            status: 'in_use',
            lastUpdated: serverTS
          });

          //  - Scooty: update currentBatteryId
          const sRef = scootyRef(currentScootyId);
          tx.set(sRef, { // use set+merge to be safe if doc was missing
            scootyId: currentScootyId,
            currentBatteryId: deviceId,
            lastUpdated: serverTS
          }, { merge: true });

          //  - Rider: set currentBatteryId
          tx.update(rRef, { currentBatteryId: deviceId, updatedAt: serverTS });
          // Mirror legacy users
          tx.set(uRef, { linkedBattery: deviceId, updatedAt: serverTS }, { merge: true });

          log('assign_battery');
          return;
        }

        // CASE B: Return battery (toggle) if it's the same one
        if(currentBatteryId === deviceId){
          // Preconditions: battery must be linked to rider’s own scooty (not someone else’s)
          if(battery.assignedScootyId && battery.assignedScootyId !== currentScootyId){
            throw new Error('This battery does not belong to your scooty. Cannot return.');
          }

          const sRef = scootyRef(currentScootyId);

          // Process:
          //  - Battery: clear both assigned fields
          tx.update(bRef, {
            assignedScootyId: null,
            assignedRiderEmail: null,
            status: 'available',
            lastUpdated: serverTS
          });

          //  - Scooty: clear currentBatteryId, keep currentRiderEmail
          tx.set(sRef, {
            scootyId: currentScootyId,
            currentBatteryId: null,
            lastUpdated: serverTS
          }, { merge: true });

          //  - Rider: clear currentBatteryId (rider may still hold the scooty)
          tx.update(rRef, { currentBatteryId: null, updatedAt: serverTS });
          // Mirror legacy users
          tx.set(uRef, { linkedBattery: null, updatedAt: serverTS }, { merge: true });

          log('return_battery');
          return;
        }

        // CASE C: Rider already has a different battery
        throw new Error(`You already have a battery (${currentBatteryId}). Please return it first by scanning that battery.`);
      } // end battery branch

      // If we reach here, type was neither
      throw new Error('Unsupported device type. Please scan a scooter or battery QR.');
    }); // end transaction
  }

  /**************************************************************************
   * ========================= UI: load user & logs ==========================
   **************************************************************************/
  // === UPDATED: Prefer `riders/{email}` for state. Fallback to legacy `users/{email}` if needed.
  async function loadUserDevices(){
    const user = auth.currentUser;
    if(!user) return;

    // Try new master-list rider doc first
    const rSnap = await db.collection('riders').doc(user.email).get();
    if(rSnap.exists){
      const r = rSnap.data() || {};
      linkedScooter.textContent = r.currentScootyId || '—';
      linkedBattery.textContent = r.currentBatteryId || '—';
      return;
    }

    // Fallback (legacy)
    const uSnap = await db.collection('users').doc(user.email).get();
    const u = uSnap.exists ? (uSnap.data()||{}) : {};
    linkedScooter.textContent = u.linkedScooter || '—';
    linkedBattery.textContent = u.linkedBattery || '—';
  }

  // load recent logs (last 50)
  async function loadLogs(){
    logList.innerHTML = `<div class="muted">Loading logs...</div>`;
    const q = db.collection('logs').orderBy('ts','desc').limit(50);
    const snap = await q.get();
    logList.innerHTML = '';
    if(snap.empty){
      logList.innerHTML = '<div class="muted">No logs yet</div>';
      return;
    }
    snap.forEach(doc=>{
      const d = doc.data();
      const when = d.ts ? new Date(d.ts.toDate()).toLocaleString() : '—';
      const el = document.createElement('div');
      el.className = 'log-item';
      el.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center">
        <div><strong>${(d.action||'').toUpperCase()}</strong> &nbsp; ${d.deviceType} <span style="opacity:.9">(${d.deviceId})</span></div>
        <div class="muted" style="font-size:12px">${when}</div>
      </div>
      <div class="muted" style="margin-top:6px">user: ${d.email} • payload: <code>${escapeHtml(d.rawPayload||'')}</code></div>`;
      logList.appendChild(el);
    });
  }
  refreshLogs.addEventListener('click', loadLogs);

  // helper to escape HTML
  function escapeHtml(s){ return (s+'').replace(/[&<>"]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

  /**************************************************************************
   * ========================= SVG UPLOAD (logo change) =====================
   * Allows upload of an SVG file and replaces inline logo preview and main SVG.
   **************************************************************************/
  /*svgUpload.addEventListener('change', (ev)=>{
    const f = ev.target.files[0];
    if(!f) return;
    if(!f.name.toLowerCase().endsWith('.svg')) return alert('Please upload an SVG file only.');
    const reader = new FileReader();
    reader.onload = (e)=>{
      const contents = e.target.result;
      // simple safety: replace the innerHTML of the preview and main logo
      try{
        svgPreview.innerHTML = contents;
        // update main header logo too (if safe)
        document.getElementById('logo-container').innerHTML = contents;
      }catch(err){
        alert('SVG parse error');
        console.error(err);
      }
    };
    reader.readAsText(f);
  });

  // Clicking the logo also opens file upload (UX)
  document.getElementById('logo-container').addEventListener('click', ()=> svgUpload.click());*/

  /**************************************************************************
   * ========================= UTIL: Page unload cleanup ====================
   **************************************************************************/
  window.addEventListener('beforeunload', ()=>{
    if(stream) stream.getTracks().forEach(t=>t.stop());
  });

  /**************************************************************************
   * ========================= INITIAL SIMPLE SETUP =========================
   * Try to load logs once if the user is already signed in
   **************************************************************************/
  (async ()=>{
    // nothing to do here beyond what onAuthStateChanged handles.
  })();

  </script>
</body>
</html>
